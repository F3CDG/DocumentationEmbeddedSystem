\hypertarget{index_firstintro}{}\section{Capitolo 1  -\/ G\+P\+I\+O custom su Zybo}\label{index_firstintro}
Questo progetto mostra come sia possibile tramite specifici driver, pilotare una o più periferiche di G\+P\+IO. Saranno mostrate 3 versioni ma del tutto equivalenti. \hypertarget{index_firstfirst}{}\subsection{Prima versione}\label{index_firstfirst}
Libreria H\+AL driver con relativa applicazione per una G\+P\+IO custom scritta in linguaggio C\hypertarget{index_firstsecond}{}\subsection{Seconda versione}\label{index_firstsecond}
Libreria H\+AL driver con relativa applicazione per una G\+P\+IO custom scritta in linguaggio C orientato agli oggetti.\hypertarget{index_firsttirht}{}\subsection{Terza versione}\label{index_firsttirht}
Libreria H\+AL driver con relativa applicazione per una G\+P\+IO custom, arricchita del supporto alle interruzioni, scritta in linguaggio C\hypertarget{index_second}{}\section{Capitolo 2-\/ B\+S\+P custom per S\+T\+M32\+F4}\label{index_second}
Questo progetto permette di ottenere una B\+SP (Board Support Package) custom per la gestione dei led e bottone utente di una board S\+T\+M32\+F4 Discovery. Inoltre si aggiunge la possibilità di gestire una periferica di timer funzionalmente equivalente ad un contatore. Oltre all\textquotesingle{}implementazione di una B\+SP, vengono proposti 3 semplici driver che ne fanno utilizzo. Infine un esempio di applicativo che utilizza uno di questi 3 driver.\hypertarget{index_tirth}{}\section{Capitolo 3 -\/ Esempi di utilizzo delle interruzioni su board S\+TM}\label{index_tirth}
Questo progetto mostra 3 esempi di utilizzo delle interrupt secondo due livelli di astrazione\+: B\+A\+RE metal, H\+AL. \hypertarget{index_thirtfirst}{}\subsection{Interrupt B\+A\+R\+E metal}\label{index_thirtfirst}
In questo esempio si mostra una semplice I\+SR implementata a livello B\+A\+RE metal; si può notare come a tale livello di astrazione è necessaria un\textquotesingle{}intera gestione dell\textquotesingle{}evento interrompente. Nell\textquotesingle{}esempio proposto alla pressione del bottone utente viene generata una interruzione sulla periferica E\+X\+T\+I0, la quale permette ad ogni invocazione di incrementare il valore di una variabile, che nella fattispecie realizza un contatore modulo 16. Si evidenzia come l\textquotesingle{}ultima istruzione della I\+SR sia necessaria affinché il processore effettui il cambio di contesto ritornando così all\textquotesingle{}esecuzione del programma principale. \hypertarget{index_thirthsecond}{}\subsection{Interrupt H\+AL}\label{index_thirthsecond}
Sull\textquotesingle{}esempio descritto in precedenza, si mostra un modo alternativo per gestire le interruzioni. In particolare a livello H\+AL è astratto tutto il meccanismo alla corretta gestione dell\textquotesingle{}interruzione. Si rende necessario solo l\textquotesingle{}implementazione della logica utente. \hypertarget{index_thirtthirth}{}\subsection{Interrupt B\+A\+R\+E metal versione 2}\label{index_thirtthirth}
Rispetto alla versione B\+A\+RE metal descritta in precedenza, l\textquotesingle{}interruzione viene lanciata su E\+X\+T\+I1.\hypertarget{index_fourth}{}\section{Capitolo 4 -\/  Esempi di utilizzo dei bus seriali su S\+TM}\label{index_fourth}
Sono riportati 3 esempi di utilizzo di interconnessione tra due board di S\+T\+Microeletrinics in cui si esegue una trasmissione di un messaggio tra una board configurata per essere utilizzata da master e un\textquotesingle{}altra per essere utilizzata da slave. \hypertarget{index_fourthone}{}\subsection{S\+PI}\label{index_fourthone}
Quando è premuto il push-\/button sulla board che funge da master si genera una interrupt che fa eseguire la trasmit di un dato allo slave che quando riceve il messaggio fa il toggle su un led.

La configurazione tra le due periferiche è la seguente \begin{DoxyVerb}        MASTER         SLAVE
    PB13 (SPI2_SCK) ------> PB13 (SLAVE_SCK)
    PB14 (SPI2_MISO)------> PB14 (SLAVE_MISO)
    PB15 (SPI2_MOSI)------> PB15 (SLAVE_MOSI)
    PB12 (SPI2_NSS) ------> PB12 (SLAVE_NSS)
\end{DoxyVerb}
 \hypertarget{index_fourthtwo}{}\subsection{I2C}\label{index_fourthtwo}
Si simula lo stesso esempio visto per S\+PI, quando è premuto il push-\/button sulla board configurata da master si genera una interrupt che fa eseguire la trasmissione di un dato allo slave di un determinato indirizzo concordato.

La configurazione tra le due periferiche è la seguente \begin{DoxyVerb}         MASTER               SLAVE
    PB6 (I2C1_SDA) ------> PB6 (SLAVE_SDA)
    PB7 (I2C1_SCL) ------> PB7 (SLAVE_SCL)
\end{DoxyVerb}
 \hypertarget{index_fourththree}{}\subsection{U\+A\+RT}\label{index_fourththree}
Si è in attesa che si preme il push button sulla board configurata da master, per poter generare una trasmissione. Se la trasmissione è completata con successo, si fa un toggle sul L\+E\+D6, e si procede al polling di una ricezione. Se anche la ricezione è completata con successo, si accende il led associato al dato ricevuto in receive\+\_\+data e si incrementa il valore ricevuto, di una unità per poterlo inviare di nuovo al master. La configurazione tra le due periferiche è la seguente \begin{DoxyVerb}        MASTER      SLAVE
    PA2 (UART_TX) ------> PA3 (SLAVE_UART RX)
    PA3 (UART_RX) ------> PA2 (SLAVE UART TX)
\end{DoxyVerb}
\hypertarget{index_fifth}{}\section{Capitolo 5 -\/ Esempi di utilizzo dell\textquotesingle{}\+Universal Serial Bus su S\+T\+M32}\label{index_fifth}
Questo progetto mostra 2 esempi di utilizzo dell\textquotesingle{}U\+SB su board S\+T\+M32; il primo evidenzia un semplice meccanismo per l\textquotesingle{}invio dati in maniera seriale, il secondo invece l\textquotesingle{}implementazione di un device U\+SB. \hypertarget{index_fifthfirst}{}\subsection{Virtual C\+O\+M Port}\label{index_fifthfirst}
In questo esempio viene mostrato come tramite l\textquotesingle{}utilizzo della classe C\+DC (Communication Device Class) sia possibile simulare un trasferimento seriale U\+A\+RT, sfruttando una porta C\+OM virtuale. Tale applicazione può essere sfruttata in altri contesti per stampare messaggi su video a scopo di debug. L\textquotesingle{}esercizio proposto è implementato sfruttando il middlware (già presente nella libreria C\+U\+BE) relativo alle virtual C\+OM port. \hypertarget{index_fifthsecond}{}\subsubsection{Mouse U\+SB}\label{index_fifthsecond}
In questo esempio viene mostrato come sfruttando l\textquotesingle{}accellerometro in dotazione alla board S\+T\+M32\+F4 Discovery, è possibile implementare un mouse sfruttando il middlware relativo alle periferiche H\+ID. \hypertarget{index_six}{}\section{Capitolo 6  -\/ Kernel}\label{index_six}
Tale Capitolo è sprovvisto di documentazione interna. \hypertarget{index_secondintro}{}\section{Capitolo 7  -\/\+Driver Linux}\label{index_secondintro}
In questa documentazione sono presenti dei driver per SO Linux al fine di controllare scrittura e lettura di una G\+P\+IO. I driver sono stati sviluppat sia per la G\+P\+IO fornita dalla Xilinx, sia per una G\+P\+IO custom realizzata ai fini dell\textquotesingle{}esame di Sistemi Embedded e presente nel capitolo 1 della documentazione. \hypertarget{index_seven}{}\subsection{Prima tipologia di driver}\label{index_seven}
Con questa tipologia di driver l\textquotesingle{}accesso ai registri della periferica G\+Pio viene effettuato utilizzando direttamente l\textquotesingle{}indirizzo fisico della periferica. Per la precisione, dato il meccanismo di virtualizzazione del SO, da tale indirizzo viene ricavato, tramite la system call mmap, un indirizzo virtuale. Tramite questo vengono effettuate le operazioni di lettura e scrittura, fornendo opportunamente alle funzioni gli spiazzamenti dei registri interni della periferica. Per ulteriore approfondimento si rimanda a \href{https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf}{\tt https\+://www.\+xilinx.\+com/support/documentation/ip\+\_\+documentation/axi\+\_\+gpio/v2\+\_\+0/pg144-\/axi-\/gpio.\+pdf}. \hypertarget{index_sevensecond}{}\subsection{Seconda tipologia di driver}\label{index_sevensecond}
Il driver è simile al precedente. La principale differenza sta nel fatto che non si accede più alla periferica tramite indirizzo fisico, ma attraverso il device uio file che viene riconosciuto dal SO. E\textquotesingle{} chiaro che per utilizzare questa tipologia di driver, bisogna configurare il kernel Linux in modo tale da prevedere l\textquotesingle{}impiego di driver uio. Una volta acceduto alla periferica, il funzionamento è praticamente lo stesso del precedente driver. \hypertarget{index_seventhird}{}\subsection{Terza tipologia di driver}\label{index_seventhird}
Quest\textquotesingle{}ultima tipologia è simile alla precedente per quanto riguarda la modalità di accesso alla periferica. La differenza sta nell\textquotesingle{}utilizzo del meccanismo delle interruzioni per la lettura. In base alla G\+P\+IO utilizzata, quando avviene un\textquotesingle{}operazione di lettura, la prima istruzione eseguita è l\textquotesingle{}abilitazione generale delle interruzioni sulla periferica. Successivamente vengono abilitate le interruzioni dei canali (se la G\+P\+IO è della Xilinx), altrimenti viene abilitata la maschera delle interruzioni di ogni singolo port (se la G\+P\+IO è quella custom). A questo punto il processo si sospende sulla periferica mediante un\textquotesingle{}operazione di read. Quando viene risvegliato dall\textquotesingle{}interruzione, il driver disabilita le interruzioni sopra citate, legge il valore sul porto di input infine comunica al SO di aver servito l\textquotesingle{}interruzione e pulisce il registro di status della periferica.\hypertarget{index_eight}{}\section{Capitolo 8 -\/ Esempi di utilizzo del Sistema Operativo Free\+Rtos su S\+T\+M32\+F4\+Discovery}\label{index_eight}
E\textquotesingle{} riportato il codice utilizzato per implementare diversi esempi di utilizzo di task attraverso il sistema operativo Free\+R\+T\+OS. Sono state effettuate diverse simulazioni variando sia il numero di task che il valore delle macro Priority e Delay. 