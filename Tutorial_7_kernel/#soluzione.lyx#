#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{listings,xcolor,courier,bookmark}
\usepackage{listingsutf8}
\definecolor{darkblue}{named}{blue}
\definecolor{darkred}{named}{red}
\definecolor{grau}{named}{gray}
\let\Righttorque\relax
\lstset{
captionpos=b,
commentstyle=\color[rgb]{0.133,0.545,0.133},
keywordstyle=\color{darkblue},
stringstyle=\color{darkred},
extendedchars=true,
basicstyle=\small\ttfamily,
showstringspaces=false,
tabsize=2,
numbers=left,
numberstyle=\tiny,
breakautoindent  = true,
breakindent      = 2em,
breaklines       = true,
postbreak        = ,
prebreak         = \raisebox{-.8ex}[0ex][0ex]{\Righttorque},
showspaces=false, 
showtabs=false, 
showstringspaces=false,
language=VHDL,
frame=single,
morecomment=[s]{--}
}


\renewcommand*{\lstlistingname}{Codice}


\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead{} 
\fancyfoot{} 

\fancyhead[RO,LE]{\bfseries \leftmark}
\fancyfoot[LE,RO]{\thepage}
\fancyfoot[LO,CE]{Tesina in SE: Sistemi Embedded}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\date{}
\cfoot{}
\end_preamble
\use_default_options true
\master Tesina.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2.5cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Procedimento
\end_layout

\begin_layout Subsection
Prima tipologia
\end_layout

\begin_layout Standard
Questa prima modalità è quella, forse, più difficile da trovare nella realtà.
 Per fare uso di un driver del genere, infatti, non solo bisogna conoscere
 l'esatto indirizzo fisico della periferica a cui si vuole accedere, ma
 bisogna anche avere i privilegi di root nell'esecuzione del driver.
 Il perchè è presto spiegato: tale meccanismo prevede di accedere direttamente
 alla memoria, che in Linux è vista come un file sotto /dev (/dev/mem).
 Più avanti nella trattazione si capirà ancora meglio tale concetto.
\end_layout

\begin_layout Standard
Di seguito si descrivono i file utilizzati per la scrittura del driver,
 andando ad evidenziare le principali pecuiliarità di ognuno di essi.
\end_layout

\begin_layout Subsubsection
nodriver_header.h
\end_layout

\begin_layout Standard
Dopo aver richiamato alcune librerie utili per la definizione delle funzioni,
 si definiscono le macro RESET, GREEN e BOLDWHITE.
 Queste vengono utilizzate nella stampa di alcuni messaggi a terminale,
 per rendere più fruibile la lettura.
 Le macro READ e WRITE sono invece utilizzate per definire se l'operazione
 che si vuole eseguire sulla periferica GPIO è di lettura o scrittura.
 La macro PAGE_SIZE ha come valore la grandezza della pagina che il sistema
 operativo usa nel meccanismo della paginazione.
 MASK_SIZE, invece, è una maschera di bit composta da tutti 1, eccetto che
 nella parte finale dove sono presenti tanti 0 quanti sono i bit che occorrono
 per definire l'offset di una pagina.
 A titolo d'esempio, si supponga che il SO utilizzi un sistema di paginazione
 con pagine grandi 
\begin_inset Formula $2^{4}$
\end_inset

 bit = 
\begin_inset Formula $0...010000$
\end_inset

 Tale valore viene resituito dalla system call 
\series bold
sysconf(_SC_PAGESIZE)
\series default
 e associato alla macro PAGE_SIZE.
 Dato un certo indirizzo di memoria, per estrapolare il numero di pagina,
 escludendo, quindi, il suo offset, si utilizza, appunto, MASK_SIZE.
 Nel caso preso d'esempio questa sarà pari a 
\begin_inset Formula $1.....110000$
\end_inset

.
 Il calcolo è molto semplice, basta sottrarre 1 e negare tutto il risultato.
 Infine, vengono definiti i prototipi di tutte le funzioni che saranno richiamat
e all'interno del driver.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="nodriver header.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	nodriver.h
\end_layout

\begin_layout Plain Layout

  * @author	Colella Gianni - Guida Ciro - Lombardi Daniele
\end_layout

\begin_layout Plain Layout

  *		Group IV - Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	22-June-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	library nodriver gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <unistd.h>
\end_layout

\begin_layout Plain Layout

#include <sys/mman.h>
\end_layout

\begin_layout Plain Layout

#include <fcntl.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Colour MACRO --------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define RESET		"
\backslash
033[0m"		/*!< Reset colour */
\end_layout

\begin_layout Plain Layout

#define GREEN   	"
\backslash
033[32m"     		/*!< Green colour */
\end_layout

\begin_layout Plain Layout

#define BOLDWHITE	"
\backslash
033[1m
\backslash
033[37m"	/*!< Bold White colour */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO operation MACRO ------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define READ 0
\end_layout

\begin_layout Plain Layout

#define WRITE 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO page MACRO ------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define PAGE_SIZE sysconf(_SC_PAGESIZE) 	/*!< Page size used by SO */
\end_layout

\begin_layout Plain Layout

#define MASK_SIZE (~(PAGE_SIZE-1))		/*!< Bit mask to extract page address,
 without offset */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Function prototypes -------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void usage(char *name);	/*!< usage function is called to help the user */
\end_layout

\begin_layout Plain Layout

int parse_command(int argc,char **argv,int* address,int* r_w,int* value);
 /*!< parse_command function is called to parse arguments passed to driver
 */
\end_layout

\begin_layout Plain Layout

int open_memory(int* fd,int phy_address, int* page_offset,void** virtual_address
);/*!< open_memory function is called to open memory file */
\end_layout

\begin_layout Plain Layout

void read_gpio(int* value,void* virtual_address,int page_offset);/*!< read_gpio
 function is called to do read operation from GPIO */
\end_layout

\begin_layout Plain Layout

void write_gpio(int value,int phy_address,void* virtual_address, int page_offset
);/*!< write_gpio function is called to do write operation on GPIO */
\end_layout

\begin_layout Plain Layout

void close_memory(int fd, void* virtual_address);/*!< close_memory function
 is called to close memory file */
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
nodriver_function.h
\end_layout

\begin_layout Standard
Di seguito la descrizione dettagliata di ogni funzione utilizzata dal driver.
\end_layout

\begin_layout Standard

\series bold
usage
\end_layout

\begin_layout Standard
Tale funzione viene chiamata ogni qual volta l'utente sbaglia ad invocare
 correttamente il driver.
 Il suo scopo è, appunto, spiegare all'utente come passare correttamente
 ogni parametro al driver per eseguire correttamente l'operazione richiesta.
 La sintassi prevede che, dopo aver digitato il nome del driver, il primo
 parametro obbligatorio da passare è l'indirizzo fisico della periferica,
 preceduto dall'opzione 
\shape italic
-g
\shape default
.
 Subito dopo, si sceglie se effettuare una lettura (digitare l'opzione -i),
 oppure se effettura una scrittura sulla GPIO (opzione -o seguita dal valore
 che si vuole scrivere).
 La funzione specifica anche che il valore passato per essere scritto può
 essere rappresentato in notazione decimale, ottale o esadecimale.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=14, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Describes how 'nodriver' must be used, specifing all supported
 options.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	name: Specifies nodriver name.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void usage(char *name){
\end_layout

\begin_layout Plain Layout

	printf("The right way to use this driver is
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"%s -g <GPIO_ADDRESS> -i|-o <VALUE>
\backslash
n"RESET,name);
\end_layout

\begin_layout Plain Layout

	printf("Please, pay attention:
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
t-g"RESET GREEN"
\backslash
t<GPIO_ADDR>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <GPIO_ADDR>
\backslash
n
\backslash
t
\backslash
tspecifies the physical address of GPIO.
\backslash
n
\backslash
t
\backslash
t<GPIO_ADDR> can be expressed in
\backslash
n
\backslash
t
\backslash
tdecimal representation (no prefix),
\backslash
n
\backslash
t
\backslash
toctal representation (0 prefix)
\backslash
n
\backslash
t
\backslash
tor hexadecimal representation
\backslash
n
\backslash
t
\backslash
t(0x or 0X prefix)
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-i"RESET"
\backslash
n
\backslash
t
\backslash
tSpecifies the input value of GPIO at
\backslash
n
\backslash
t
\backslash
t<GPIO_ADDR> physical address 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-o"RESET GREEN"
\backslash
t<VALUE>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <VALUE> specify
\backslash
n
\backslash
t
\backslash
tthe value must be write on GPIO output 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Reads the <value> in input to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	value: read value.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	virtual_address: GPIO's virtual address.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	page_offset: page offset which GPIO finds.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void read_gpio(int* value,void* virtual_address,int page_offset){
\end_layout

\begin_layout Plain Layout

	*value = *((unsigned *)(virtual_address + page_offset));
\end_layout

\begin_layout Plain Layout

	printf("The value on GPIO input is: %08x
\backslash
n",*value);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Writes <value> in output to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	value: write value.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	phy_address: GPIO's physical address.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	virtual_address: GPIO's virtual address.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	page_offset: page offset which GPIO finds.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void write_gpio(int value,int phy_address,void* virtual_address, int page_offset
){
\end_layout

\begin_layout Plain Layout

	printf("Going to write onto %08x the value %08x
\backslash
n", phy_address, value );
\end_layout

\begin_layout Plain Layout

	*((unsigned *)(virtual_address + page_offset)) = value;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Closes /dev/mem file.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	fd: file descriptor name.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	virtual_address: GPIO's virtual address.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void close_memory(int fd,void* virtual_address){
\end_layout

\begin_layout Plain Layout

	munmap(virtual_address,PAGE_SIZE);
\end_layout

\begin_layout Plain Layout

	close(fd);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
parse_command
\end_layout

\begin_layout Standard
Questa funzione ha lo scopo di analizzare tutti gli argomenti che vengono
 passati da riga di comando.
 Il meccanismo di parsing ruota attorno al corretto utilizzo della funzione
 
\series bold
getopt
\series default
, già fornita dal SO.
 Quest'ultima prende in ingresso 
\shape italic
argc
\shape default
, 
\shape italic
argv
\shape default
 e 
\shape italic
optstring
\shape default
.
 optstring è una stringa che contiene tutti gli argomenti che si vogliono
 ricercare, scritti tutti attaccato, e seguiti dal carattere ':' se tali
 argomenti devono essere seguiti da un attributo obbligatorio.
 Quando una delle stringhe, presenti in argv, comincia per il carattere
 '-', la funzione getopt restituisce il carattere immediatamente successivo.
 Ai fini implementativi, vengono dichiarate le seguenti variabili locali:
\end_layout

\begin_layout Itemize

\shape italic
index
\shape default
, contiene il valore di ritorno della funzione getopt.
 Se un particolare argomento necessita di un argomento obbligatorio e questo
 non viene passato, la funzione ritornerà il carattere ':'.
 Se, invece, viene letto un carattere non presente in optstring, la funzione
 ritorna il carattere '?'.
\end_layout

\begin_layout Itemize

\shape italic
mandatory_opt
\shape default
, utilizzata per tener traccia del fatto che sia stato analizzato o meno
 il parametro obbligatorio 'g'.
\end_layout

\begin_layout Itemize

\shape italic
i_or_o
\shape default
, utilizzata per tener traccia del fatto che sia stata richiesta almeno
 una delle due operazioni possibili, lettura o scrittura.
\end_layout

\begin_layout Itemize

\shape italic
optstring
\shape default
, contiene tutte gli argomenti che può riconoscere la funzione.
\end_layout

\begin_layout Standard
Se nel while viene riconosciuta l'opzione
\end_layout

\begin_layout Itemize
g, viene modificata la variabile 
\shape italic
mandatory_opt
\shape default
 e salvato l'indirizzo fisico della GPIO in 
\shape italic
address
\shape default
.
 Qui viene fatto anche un controllo se l'indirizzo fisico passato è diverso
 da 0x0.
\end_layout

\begin_layout Itemize
i, si effettua un controllo per capire se precedentemente è stata riconosciuta
 l'opzione obbligatoria 'g'.
 In caso affermativo si setta la variabile 
\shape italic
r_w
\shape default
 a READ e si indica che nel lanciare il driver è stata richiesta almeno
 una tra le opzioni di lettura o scrittura.
\end_layout

\begin_layout Itemize
o, si eseguono le stesse operazioni per l'argomento 'i', con la sola differenza
 del settaggio della variabile 
\shape italic
r_w
\shape default
 a WRITE.
\end_layout

\begin_layout Itemize
h, viene richiamata la funzione usage.
\end_layout

\begin_layout Itemize
:, vuol dire che non è stato passato un attributo ad un certo argomento.
 Viene, pertanto, richiamata la funzione usage per aiutare l'utente.
\end_layout

\begin_layout Itemize
?, vuol dire che l'argomento passato non è riconosciuto dal programma, Pertanto,
 dopo un messaggio di errore, ancora una volta viene richiamata la funzione
 usage.
\end_layout

\begin_layout Standard
Alla fine del while, è stato inserito un ulteriore controllo per verificare
 se nel lancio del driver è stata richiesta almeno una delle 2 operazioni
 possibili su GPIO.
\end_layout

\begin_layout Standard
In sostanza, la funzione parse_command ritorna come valore
\end_layout

\begin_layout Itemize
-1 se si è verificato un qualsiasi errore;
\end_layout

\begin_layout Itemize
1 se è stata richiamata la funzione usage;
\end_layout

\begin_layout Itemize
0 se il driver è stato lanciato rispettando la sintassi prevista dal programmato
re.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=29, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Parses nodriver arguments.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argc: number of parameters, passed to main function.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argv: parameters passed to main function
\end_layout

\begin_layout Plain Layout

  * @param  [out] 	address: physical address of GPIO component
\end_layout

\begin_layout Plain Layout

  * @param  [out]	r_w: specifies if the operation on GPIO is a read or a
 write
\end_layout

\begin_layout Plain Layout

  * @param  [out]	value: contains the read value (if the operation on GPIO
 is a read) 
\end_layout

\begin_layout Plain Layout

  * 			or the value to write (if the operation on GPIO is a write)
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *	    -1		An error occurred;
\end_layout

\begin_layout Plain Layout

  *	     1		Help function is called;		
\end_layout

\begin_layout Plain Layout

  * 	     0		Everything is ok.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int parse_command(int argc,char **argv,int* address,int* r_w,int* value){
\end_layout

\begin_layout Plain Layout

	int index=0;
\end_layout

\begin_layout Plain Layout

	int mandatory_opt=-1; /* Keep track if the mandatory option 'g' is parsed
 */
\end_layout

\begin_layout Plain Layout

	int i_or_o=0;	/* Keep track if an i|o operation is requested */
\end_layout

\begin_layout Plain Layout

	static char *optstring = ":g:io:h";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		while((index = getopt(argc, argv, optstring)) != -1) {
\end_layout

\begin_layout Plain Layout

				switch(index) {
\end_layout

\begin_layout Plain Layout

				case 'g':
\end_layout

\begin_layout Plain Layout

					mandatory_opt=atoi(optarg);	/* Change mandatory_opt value to memorize
 that the mandatory option is parsed */
\end_layout

\begin_layout Plain Layout

					*address=strtoul(optarg,NULL, 0);
\end_layout

\begin_layout Plain Layout

					/* Check if address passed is not 0x0 */
\end_layout

\begin_layout Plain Layout

					if(*address==0){
\end_layout

\begin_layout Plain Layout

						printf("Wrong physical address inserted!
\backslash
n");
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}						
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'i':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'i' option was passed the mandatory option 'g' */
\end_layout

\begin_layout Plain Layout

					if(mandatory_opt!=-1){
\end_layout

\begin_layout Plain Layout

						*r_w=READ; /* Set READ operation for GPIO */
\end_layout

\begin_layout Plain Layout

						i_or_o=1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'o':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'o' option was passed the mandatory option 'g' */
\end_layout

\begin_layout Plain Layout

					if(mandatory_opt!=-1){
\end_layout

\begin_layout Plain Layout

						*r_w=WRITE; /* Set WRITE operation for GPIO */
\end_layout

\begin_layout Plain Layout

						*value=strtoul(optarg, NULL, 0);
\end_layout

\begin_layout Plain Layout

						i_or_o=1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'h':
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return 1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case ':':
\end_layout

\begin_layout Plain Layout

					printf("Missing argument for '%c' option
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case '?':
\end_layout

\begin_layout Plain Layout

					printf("Option '%c' not recognized
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				default:
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

	/* Check if an i|o operation is requested */	
\end_layout

\begin_layout Plain Layout

	if(i_or_o==0){
\end_layout

\begin_layout Plain Layout

		printf("Can't use "BOLDWHITE"nodriver "RESET"without specify i|o option
\backslash
n");
\end_layout

\begin_layout Plain Layout

		usage(argv[0]);
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
open_memory
\end_layout

\begin_layout Standard
In questa funzione viene eseguita tutta la magia per poter accedere correttament
e ai registri della GPIO.
 Poichè il SO utilizza il meccanismo della virtualizzazione se si provasse
 ad accedere alla periferica direttamente con l'indirizzo fisico passato
 in ingresso al driver come attributo, molto probabilmente il SO resituirebbe
 un segmentation fault.
 Quello che bisogna fare è accedere ai registri tramite indirizzo virtuale,
 visto che è l'unico modo con cui è possibile comunicare con qualsiasi periferic
a.
 Il SO astrae, infatti, tutta la memoria.
 La funzione che consente di avere un indirizzo virtuale, dato un certo
 indirizzo fisico, è la system call 
\series bold
mmap
\series default
.
\end_layout

\begin_layout Standard
La prima cosa che si fa è accedere alla memoria tramite la system call 
\series bold
open
\series default
, andando a specificare di voler accedere sia in lettura sia scrittura.
 La memoria sotto Linux, viene vista come un qualsiasi file, la si accede
 tramite 
\shape italic
/dev/mem
\shape default
.
 Fatto ciò, attraverso un meccanismo di mascherazione, dall'indirizzo fisico
 viene estratto sia l'indirizzo fisico della pagina a cui è mappata la periferic
a, sia il suo offset (che poi è lo stesso anche per la pagina virtuale).
 
\end_layout

\begin_layout Standard
A questo punto, viene richiamata la mmap.
 Essendo il primo parametro NULL, allora è il Kernel a scegliere l'indirizzo
 a cui effettuare il mapping.
 Il secondo parametro, PAGE_SIZE, specifica la grandezza delle pagine viste
 dal SO; PROT_READ|PROT_WRITE indica che la pagine può essere letta e scritta.
 Il terzo parametro, MAP_SHARED, indica che le modifiche fatte al file sono
 condivise con gli altri processi mappati sulla stessa regione.
 
\shape italic
fd
\shape default
 è il descrittore che individua il file registri periferica; 
\shape italic
page_addr
\shape default
 è, invece, l'indirizzo fisico della pagina in cui si trova la periferica.
 Da qui, si capisce che la mmap accetta come indirizzo fisico solo un multiplo
 delle pagine utilizzate dal SO.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=114, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Opens /dev/mem file in order to access GPIO address and calculates
 page offset and virtual address of GPIO file.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	fd: file descriptor name.
\end_layout

\begin_layout Plain Layout

  * @param  [in] 	phy_address: GPIO's physical address.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	page_offset: page offset which GPIO finds.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	virtual_address: GPIO's virtual address.
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *         -1		An error occurred.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int open_memory(int* fd, int phy_address, int* page_offset,void** virtual_addres
s){
\end_layout

\begin_layout Plain Layout

	*fd = open ("/dev/mem", O_RDWR);
\end_layout

\begin_layout Plain Layout

		if (*fd < 1) {
\end_layout

\begin_layout Plain Layout

			perror("Error to open /dev/mem file");
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		int page_addr = phy_address & MASK_SIZE;
\end_layout

\begin_layout Plain Layout

		/* Calculates page offset */
\end_layout

\begin_layout Plain Layout

		*page_offset = phy_address - page_addr;
\end_layout

\begin_layout Plain Layout

		/* mmap system call returns virtual address of GPIO */
\end_layout

\begin_layout Plain Layout

		*virtual_address = mmap(NULL, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED,
 *fd, page_addr);
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
read_gpio
\end_layout

\begin_layout Standard
Legge il valore contenuto nella GPIO e restituisce un messaggio di avvenuta
 lettura.
 Si noti, che per eseguire correttamente l'operazione è stato aggiunto l'offset
 all'indirizzo virtuale che si ha a disposizione.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=137, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Reads the <value> in input to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  value: 		read value.
\end_layout

\begin_layout Plain Layout

  * @param  virtual_address: 	GPIO's virtual address.
\end_layout

\begin_layout Plain Layout

  * @param  page_offset: 	page offset which GPIO finds.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void read_gpio(int* value,void* virtual_address,int page_offset){
\end_layout

\begin_layout Plain Layout

	*value = *((unsigned *)(virtual_address + page_offset));
\end_layout

\begin_layout Plain Layout

	printf("The value on GPIO input is: %08x
\backslash
n",*value);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
write_gpio
\end_layout

\begin_layout Standard
Effettua la scrittura del valore passato al driver sulla periferica GPIO,
 stampando un messaggio di avvenuta scrittura.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=148, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**   
\end_layout

\begin_layout Plain Layout

* @brief  Writes <value> in output to GPIO port.
   
\end_layout

\begin_layout Plain Layout

* @param  value: 		write value.
   
\end_layout

\begin_layout Plain Layout

* @param  phy_address: 	GPIO's physical address.
   
\end_layout

\begin_layout Plain Layout

* @param  virtual_address: 	GPIO's virtual address.
   
\end_layout

\begin_layout Plain Layout

* @param  page_offset: 	page offset which GPIO finds.
   
\end_layout

\begin_layout Plain Layout

* @retval None.
   
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

void write_gpio(int value,int phy_address,void* virtual_address, int page_offset
){ 	
\end_layout

\begin_layout Plain Layout

	printf("Going to write onto %08x the value %08x
\backslash
n", phy_address, value ); 	
\end_layout

\begin_layout Plain Layout

	*((unsigned *)(virtual_address + page_offset)) = value; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
close_memory
\end_layout

\begin_layout Standard
Chiude la memoria, aperta precedentemente, invocando la system call munmap,
 alla quale viene passato l'indirizzo virtuale del file aperto e la grandezza
 delle pagine.
 Infine, si richiama la close per chiudere il descrittore di file.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=161, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Closes /dev/mem file.
\end_layout

\begin_layout Plain Layout

  * @param  virtual_address: 	GPIO's virtual address.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void close_memory(int fd, void* virtual_address){
\end_layout

\begin_layout Plain Layout

	munmap(virtual_address,PAGE_SIZE);
\end_layout

\begin_layout Plain Layout

	close(fd);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
main.c
\end_layout

\begin_layout Standard
La funzione main è molto semplice.
 Dopo aver dichiarato una serie di variabili da passare alle funzioni, la
 prima operazione eseguita è verificare che la funzione adibita al parsing
 degli argomenti non restituisca nessun errore.
 Dopodichè si controlla che l'accesso in memoria non provochi errore.
 In funzione del valore della variabile 
\shape italic
r_or_w
\shape default
, quindi, viene richiamata la funzione di lettura o di scrittura.
 Infine, c'è la chiamata alla close_memory.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="main.c"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	main.c
\end_layout

\begin_layout Plain Layout

  * @authors	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	22-June-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	driver "nodriver" to control gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include "nodriver_header.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[]){
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	int file_descriptor; /*!< Memory file descriptor */
\end_layout

\begin_layout Plain Layout

	int r_w=READ;	/*!< Saves operation's type to do with GPIO */
\end_layout

\begin_layout Plain Layout

	int r_or_w_value = 0;	/*!< Saves read/write value from/on GPIO */
\end_layout

\begin_layout Plain Layout

	int ret_parse;	/*!< Returned value from parse_command function */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	unsigned phy_addr, page_off;	/*!< Respectively physical address of GPIO
 and page offset */
\end_layout

\begin_layout Plain Layout

	void *virt_addr;	/*!< Virtual address of GPIO */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/*! Check if parse_command function returns error */
\end_layout

\begin_layout Plain Layout

	if((ret_parse=parse_command(argc,argv,&phy_addr,&r_w,&r_or_w_value))==1)
\end_layout

\begin_layout Plain Layout

		return 0;
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		if(ret_parse==-1)
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	/*! Check if open_memory function returns error */
\end_layout

\begin_layout Plain Layout

	if(open_memory(&file_descriptor,phy_addr,&page_off,&virt_addr)==-1){
\end_layout

\begin_layout Plain Layout

		printf("nodriver aborted!
\backslash
n");
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	/*! Calls conveniently read_gpio or write_gpio */
\end_layout

\begin_layout Plain Layout

	if (r_w == READ) read_gpio(&r_or_w_value,virt_addr,page_off);
\end_layout

\begin_layout Plain Layout

	else write_gpio(r_or_w_value,phy_addr,virt_addr,page_off);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	close_memory(file_descriptor,virt_addr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
makefile
\end_layout

\begin_layout Standard
Per completezza, si riporta anche un semplice makefile realizzato per agevolare
 la fase di compilazione del driver, utilizzando la primitiva 
\family typewriter
make
\family default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=bash, caption="makefile"]
\end_layout

\begin_layout Plain Layout

nodriver : main.o nodriver_function.o
\end_layout

\begin_layout Plain Layout

	cc -o nodriver main.o nodriver_function.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main.o : main.c nodriver_function.c nodriver_header.h
\end_layout

\begin_layout Plain Layout

	cc -c main.c -o main.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

nodriver_function.o : nodriver_function.c nodriver_header.h
\end_layout

\begin_layout Plain Layout

	cc -c nodriver_function.c -o nodriver_function.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clean :
\end_layout

\begin_layout Plain Layout

	rm -f nodriver
\end_layout

\begin_layout Plain Layout

	rm *.o
\end_layout

\begin_layout Plain Layout

	echo "Clean all file!"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Esempio di esecuzione
\end_layout

\begin_layout Standard
In questa sezione viene mostrato come eseguire il driver appena scritto
 per pilotare led, switch e button della board Zybo.
 Per la buona riuscita di questa parte esercitativa, si precisa che è necessario
 essere riusciti a completare il booting da SD card, descritto nel capitolo
 precedente.
\end_layout

\begin_layout Standard
Per prima cosa, all'interno della partizione BOOT_F della SD card, si crea
 una cartella 
\shape italic
driver
\shape default
 al cui interno si andranno a mettere le 3 tipologie di driver richieste
 dalla traccia.
 Collegare la scheda al computer, aprire un terminale ed eseguire
\end_layout

\begin_layout Standard
\align center

\family typewriter
mkdir /media/daniele/BOOT_F/driver
\end_layout

\begin_layout Standard
digitare, infine, i comandi
\end_layout

\begin_layout Standard
\align center

\family typewriter
mkdir /media/daniele/BOOT_F/driver/nodriver 
\end_layout

\begin_layout Standard
\align center

\family typewriter
mkdir /media/daniele/BOOT_F/driver/uio 
\end_layout

\begin_layout Standard
\align center

\family typewriter
mkdir /media/daniele/BOOT_F/driver/uio_int 
\end_layout

\begin_layout Standard
per creare rispettivamente le cartelle in cui vanno inseriti il primo, secondo
 e terzo tipo di driver.
\end_layout

\begin_layout Standard
Si copiano, quindi, i file scritti all'interno della cartella corrispondente.
 Nel caso considerato il comando è
\end_layout

\begin_layout Standard
\align center

\family typewriter
cp -a Sistemi_Embedded/Esercitazione_7/Driver/0_noDriver/.
 /media/daniele/BOOT_F/driver/nodriver/
\end_layout

\begin_layout Standard
Eseguire l'operazione di umount delle partizioni
\end_layout

\begin_layout Standard
\align center

\family typewriter
umount /media/daniele/BOOT_F 
\end_layout

\begin_layout Standard
\align center

\family typewriter
umount /media/daniele/ROOT_FS 
\end_layout

\begin_layout Standard
Seguendo le indicazioni del precedente capitolo, si setta la board in modo
 tale da essere avviata via SD.
 Si apre un emulatore di terminale e si fa il reboot del SO.
\end_layout

\begin_layout Standard
Per prima, cosa si monta la partizione BOOT_F in 
\shape italic
/mnt
\end_layout

\begin_layout Standard
\align center

\family typewriter
mount /dev/mmcblk0p1 /mnt/
\end_layout

\begin_layout Standard
Con i comandi seguenti, si accede quindi alla cartella nella quale è stato
 caricato il driver
\end_layout

\begin_layout Standard
\align center

\family typewriter
cd /mnt/driver/nodriver
\end_layout

\begin_layout Standard
digitando 
\family typewriter
ls
\family default
 il risultato dovrebbe essere
\end_layout

\begin_layout Standard
\align center

\family typewriter
\color red
main.c makefile nodriver_function.c nodriver_header.h
\end_layout

\begin_layout Standard
Compiliamo il driver con la primitiva
\end_layout

\begin_layout Standard
\align center

\family typewriter
make
\end_layout

\begin_layout Standard
Per passare i giusti parametri al driver, bisogna conoscere gli esatti indirizzi
 delle periferiche sviluppate nel capitolo precedente.
 A tal fine, si avvia Vivado, si apre il progetto in questione e, dopo aver
 aperto il block diagram, si apre la paletta 
\series bold
Address Editor
\series default
, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Address-Editor"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_0.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Address-Editor"

\end_inset

Address Editor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dove
\end_layout

\begin_layout Itemize
axi_gpio_0 è la GPIO associata ai bottoni;
\end_layout

\begin_layout Itemize
axi_gpio_1 è la GPIO associata agli switch;
\end_layout

\begin_layout Itemize
axi_gpio_2 è la GPIO associata ai led.
\end_layout

\begin_layout Standard
Nelle figure che seguono si riportano alcuni esempi di funzionamento, in
 particolare si mostra:
\end_layout

\begin_layout Itemize
una lettura sui button, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:button"

\end_inset

;
\end_layout

\begin_layout Itemize
una lettura sugli switch, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:switch"

\end_inset

;
\end_layout

\begin_layout Itemize
una scrittura sui led, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:led"

\end_inset

;
\end_layout

\begin_layout Itemize
il richiamo della funzione di help, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:usage"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_1.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:button"

\end_inset

Messaggio restituito dopo la pressione di BTN2(V16) e BTN3(Y16) 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_2.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:switch"

\end_inset

Messaggio restituito dopo aver alzato SW0(G15) e SW2(W13)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_3.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:led"

\end_inset

Messaggio restituito dopo che sulla board si sono accesi LD0(M14), LD1(M15)
 e LD2(G14)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_4.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:usage"

\end_inset

Usage function
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Seconda tipologia
\end_layout

\end_body
\end_document
