#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{listings,xcolor,courier,bookmark}
\usepackage{listingsutf8}
\definecolor{darkblue}{named}{blue}
\definecolor{darkred}{named}{red}
\definecolor{grau}{named}{gray}
\let\Righttorque\relax
\lstset{
captionpos=b,
commentstyle=\color[rgb]{0.133,0.545,0.133},
keywordstyle=\color{darkblue},
stringstyle=\color{darkred},
extendedchars=true,
basicstyle=\small\ttfamily,
showstringspaces=false,
tabsize=2,
numbers=left,
numberstyle=\tiny,
breakautoindent  = true,
breakindent      = 2em,
breaklines       = true,
postbreak        = ,
prebreak         = \raisebox{-.8ex}[0ex][0ex]{\Righttorque},
showspaces=false, 
showtabs=false, 
showstringspaces=false,
language=VHDL,
frame=single,
morecomment=[s]{--}
}


\renewcommand*{\lstlistingname}{Codice}


\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead{} 
\fancyfoot{} 

\fancyhead[RO,LE]{\bfseries \leftmark}
\fancyfoot[LE,RO]{\thepage}
\fancyfoot[LO,CE]{Tesina in SE: Sistemi Embedded}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\date{}
\cfoot{}
\end_preamble
\use_default_options true
\master Tesina.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2.5cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Procedimento: GPIO Xilinx
\end_layout

\begin_layout Standard
I driver di seguito presentati fanno riferimento tutti unicamente alla periferic
a GPIO Xilinx.
\end_layout

\begin_layout Subsection
Prima tipologia
\end_layout

\begin_layout Standard
Questa prima modalità è quella, forse, più difficile da trovare nella realtà.
 Per fare uso di un driver del genere, infatti, non solo bisogna conoscere
 l'esatto indirizzo fisico della periferica a cui si vuole accedere, ma
 bisogna anche avere i privilegi di root nell'esecuzione del driver.
 Il perchè è presto spiegato: tale meccanismo prevede di accedere direttamente
 alla memoria, che in Linux è vista come un file sotto /dev (/dev/mem).
 Più avanti nella trattazione si capirà ancora meglio tale concetto.
\end_layout

\begin_layout Standard
Di seguito si descrivono i file utilizzati per la scrittura del driver,
 andando ad evidenziare le principali pecuiliarità di ognuno di essi.
\end_layout

\begin_layout Subsubsection
nodriver_header.h
\end_layout

\begin_layout Standard
Dopo aver richiamato alcune librerie utili per la definizione delle funzioni,
 si definiscono le macro RESET, GREEN e BOLDWHITE.
 Queste vengono utilizzate nella stampa di alcuni messaggi a terminale,
 per rendere più fruibile la lettura.
 Le macro READ e WRITE sono invece utilizzate per definire se l'operazione
 che si vuole eseguire sulla periferica GPIO è di lettura o scrittura.
 La macro PAGE_SIZE ha come valore la grandezza della pagina che il sistema
 operativo usa nel meccanismo della paginazione.
 MASK_SIZE, invece, è una maschera di bit composta da tutti 1, eccetto che
 nella parte finale dove sono presenti tanti 0 quanti sono i bit che occorrono
 per definire l'offset di una pagina.
 A titolo d'esempio, si supponga che il SO utilizzi un sistema di paginazione
 con pagine grandi 
\begin_inset Formula $2^{4}$
\end_inset

 bit = 
\begin_inset Formula $0...010000$
\end_inset

 Tale valore viene resituito dalla system call 
\series bold
sysconf(_SC_PAGESIZE)
\series default
 e associato alla macro PAGE_SIZE.
 Dato un certo indirizzo di memoria, per estrapolare il numero di pagina,
 escludendo, quindi, il suo offset, si utilizza, appunto, MASK_SIZE.
 Nel caso preso d'esempio questa sarà pari a 
\begin_inset Formula $1.....110000$
\end_inset

.
 Il calcolo è molto semplice, basta sottrarre 1 e negare tutto il risultato.
 Infine, vengono definiti i prototipi di tutte le funzioni che saranno richiamat
e all'interno del driver.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=192, caption="nodriver header.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	nodriver.h
\end_layout

\begin_layout Plain Layout

  * @author	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	22-June-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	library nodriver gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <unistd.h>
\end_layout

\begin_layout Plain Layout

#include <sys/mman.h>
\end_layout

\begin_layout Plain Layout

#include <fcntl.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Colour MACRO --------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define RESET		"
\backslash
033[0m"		/*!< Reset colour */
\end_layout

\begin_layout Plain Layout

#define GREEN   	"
\backslash
033[32m"     		/*!< Green colour */
\end_layout

\begin_layout Plain Layout

#define BOLDWHITE	"
\backslash
033[1m
\backslash
033[37m"	/*!< Bold White colour */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO operation MACRO ------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define READ 0					/*!< Read operation is set */
\end_layout

\begin_layout Plain Layout

#define WRITE 1					/*!< Write operation is set */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO page MACRO -----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define PAGE_SIZE sysconf(_SC_PAGESIZE) 	/*!< Page size used by SO */
\end_layout

\begin_layout Plain Layout

#define MASK_SIZE (~(PAGE_SIZE-1))		/*!< Bit mask to extract page address,
 without offset */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Function prototypes -------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void usage(char *name);	/*!< usage function is called to help the user */
\end_layout

\begin_layout Plain Layout

int parse_command(int argc,char **argv,int* address,int* r_w,int* value);
 /*!< parse_command function is called to parse arguments passed to driver
 */
\end_layout

\begin_layout Plain Layout

int open_memory(int* fd,int phy_address, int* page_offset,void** virtual_address
);/*!< open_memory function is called to open memory file */
\end_layout

\begin_layout Plain Layout

void read_gpio(int* value,void* virtual_address,int page_offset);/*!< read_gpio
 function is called to do read operation from GPIO */
\end_layout

\begin_layout Plain Layout

void write_gpio(int value,int phy_address,void* virtual_address, int page_offset
);/*!< write_gpio function is called to do write operation on GPIO */
\end_layout

\begin_layout Plain Layout

void close_memory(int fd, void* virtual_address);/*!< close_memory function
 is called to close memory file */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
nodriver_function.h
\end_layout

\begin_layout Standard
Di seguito la descrizione dettagliata di ogni funzione utilizzata dal driver.
\end_layout

\begin_layout Standard

\series bold
usage
\end_layout

\begin_layout Standard
Tale funzione viene chiamata ogni qual volta l'utente sbaglia ad invocare
 correttamente il driver.
 Il suo scopo è, appunto, spiegare all'utente come passare correttamente
 ogni parametro al driver per eseguire correttamente l'operazione richiesta.
 La sintassi prevede che, dopo aver digitato il nome del driver, il primo
 parametro obbligatorio da passare è l'indirizzo fisico della periferica,
 preceduto dall'opzione 
\shape italic
-g
\shape default
.
 Subito dopo, si sceglie se effettuare una lettura (digitare l'opzione -i),
 oppure se effettura una scrittura sulla GPIO (opzione -o seguita dal valore
 che si vuole scrivere).
 La funzione specifica anche che il valore passato per essere scritto può
 essere rappresentato in notazione decimale, ottale o esadecimale.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=14, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Describes how 'nodriver' must be used, specifing all supported
 options.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	name: Specifies nodriver name.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void usage(char *name){
\end_layout

\begin_layout Plain Layout

	printf("The right way to use this driver is
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"%s -g <GPIO_ADDRESS> -i|-o <VALUE>
\backslash
n"RESET,name);
\end_layout

\begin_layout Plain Layout

	printf("Please, pay attention:
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
t-g"RESET GREEN"
\backslash
t<GPIO_ADDR>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <GPIO_ADDR>
\backslash
n
\backslash
t
\backslash
tspecifies the physical address of GPIO.
\backslash
n
\backslash
t
\backslash
t<GPIO_ADDR> can be expressed in
\backslash
n
\backslash
t
\backslash
tdecimal representation (no prefix),
\backslash
n
\backslash
t
\backslash
toctal representation (0 prefix)
\backslash
n
\backslash
t
\backslash
tor hexadecimal representation
\backslash
n
\backslash
t
\backslash
t(0x or 0X prefix)
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-i"RESET"
\backslash
n
\backslash
t
\backslash
tSpecifies the input value of GPIO at
\backslash
n
\backslash
t
\backslash
t<GPIO_ADDR> physical address 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-o"RESET GREEN"
\backslash
t<VALUE>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <VALUE> specify
\backslash
n
\backslash
t
\backslash
tthe value must be write on GPIO output 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
parse_command
\end_layout

\begin_layout Standard
Questa funzione ha lo scopo di analizzare tutti gli argomenti che vengono
 passati da riga di comando.
 Il meccanismo di parsing ruota attorno al corretto utilizzo della funzione
 
\series bold
getopt
\series default
, già fornita dal SO.
 Quest'ultima prende in ingresso 
\shape italic
argc
\shape default
, 
\shape italic
argv
\shape default
 e 
\shape italic
optstring
\shape default
.
 optstring è una stringa che contiene tutti gli argomenti che si vogliono
 ricercare, scritti tutti attaccato, e seguiti dal carattere ':' se tali
 argomenti devono essere seguiti da un attributo obbligatorio.
 Quando una delle stringhe, presenti in argv, comincia per il carattere
 '-', la funzione getopt restituisce il carattere immediatamente successivo.
 Ai fini implementativi, vengono dichiarate le seguenti variabili locali:
\end_layout

\begin_layout Itemize

\shape italic
index
\shape default
, contiene il valore di ritorno della funzione getopt.
 Se un particolare argomento necessita di un argomento obbligatorio e questo
 non viene passato, la funzione ritornerà il carattere ':'.
 Se, invece, viene letto un carattere non presente in optstring, la funzione
 ritorna il carattere '?'.
\end_layout

\begin_layout Itemize

\shape italic
mandatory_opt
\shape default
, utilizzata per tener traccia del fatto che sia stato analizzato o meno
 il parametro obbligatorio 'g'.
\end_layout

\begin_layout Itemize

\shape italic
i_or_o
\shape default
, utilizzata per tener traccia del fatto che sia stata richiesta almeno
 una delle due operazioni possibili, lettura o scrittura.
\end_layout

\begin_layout Itemize

\shape italic
optstring
\shape default
, contiene tutte gli argomenti che può riconoscere la funzione.
\end_layout

\begin_layout Standard
Se nel while viene riconosciuta l'opzione
\end_layout

\begin_layout Itemize
g, viene modificata la variabile 
\shape italic
mandatory_opt
\shape default
 e salvato l'indirizzo fisico della GPIO in 
\shape italic
address
\shape default
.
 Qui viene fatto anche un controllo se l'indirizzo fisico passato è diverso
 da 0x0.
\end_layout

\begin_layout Itemize
i, si effettua un controllo per capire se precedentemente è stata riconosciuta
 l'opzione obbligatoria 'g'.
 In caso affermativo si setta la variabile 
\shape italic
r_w
\shape default
 a READ e si indica che nel lanciare il driver è stata richiesta almeno
 una tra le opzioni di lettura o scrittura.
\end_layout

\begin_layout Itemize
o, si eseguono le stesse operazioni per l'argomento 'i', con la sola differenza
 del settaggio della variabile 
\shape italic
r_w
\shape default
 a WRITE.
\end_layout

\begin_layout Itemize
h, viene richiamata la funzione usage.
\end_layout

\begin_layout Itemize
:, vuol dire che non è stato passato un attributo ad un certo argomento.
 Viene, pertanto, richiamata la funzione usage per aiutare l'utente.
\end_layout

\begin_layout Itemize
?, vuol dire che l'argomento passato non è riconosciuto dal programma, Pertanto,
 dopo un messaggio di errore, ancora una volta viene richiamata la funzione
 usage.
\end_layout

\begin_layout Standard
Alla fine del while, è stato inserito un ulteriore controllo per verificare
 se nel lancio del driver è stata richiesta almeno una delle 2 operazioni
 possibili su GPIO.
\end_layout

\begin_layout Standard
In sostanza, la funzione parse_command ritorna come valore
\end_layout

\begin_layout Itemize
-1 se si è verificato un qualsiasi errore;
\end_layout

\begin_layout Itemize
1 se è stata richiamata la funzione usage;
\end_layout

\begin_layout Itemize
0 se il driver è stato lanciato rispettando la sintassi prevista dal programmato
re.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=29, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Parses nodriver arguments.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argc: number of parameters, passed to main function.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argv: parameters passed to main function
\end_layout

\begin_layout Plain Layout

  * @param  [out] 	address: physical address of GPIO component
\end_layout

\begin_layout Plain Layout

  * @param  [out]	r_w: specifies if the operation on GPIO is a read or a
 write
\end_layout

\begin_layout Plain Layout

  * @param  [out]	value: contains the read value (if the operation on GPIO
 is a read) 
\end_layout

\begin_layout Plain Layout

  * 			or the value to write (if the operation on GPIO is a write)
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *	    -1		An error occurred;
\end_layout

\begin_layout Plain Layout

  *	     1		Help function is called;		
\end_layout

\begin_layout Plain Layout

  * 	     0		Everything is ok.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int parse_command(int argc,char **argv,int* address,int* r_w,int* value){
\end_layout

\begin_layout Plain Layout

	int index=0;
\end_layout

\begin_layout Plain Layout

	int mandatory_opt=-1; /* Keep track if the mandatory option 'g' is parsed
 */
\end_layout

\begin_layout Plain Layout

	int i_or_o=0;	/* Keep track if an i|o operation is requested */
\end_layout

\begin_layout Plain Layout

	static char *optstring = ":g:io:h";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		while((index = getopt(argc, argv, optstring)) != -1) {
\end_layout

\begin_layout Plain Layout

				switch(index) {
\end_layout

\begin_layout Plain Layout

				case 'g':
\end_layout

\begin_layout Plain Layout

					mandatory_opt=atoi(optarg);	/* Change mandatory_opt value to memorize
 that the mandatory option is parsed */
\end_layout

\begin_layout Plain Layout

					*address=strtoul(optarg,NULL, 0);
\end_layout

\begin_layout Plain Layout

					/* Check if address passed is not 0x0 */
\end_layout

\begin_layout Plain Layout

					if(*address==0){
\end_layout

\begin_layout Plain Layout

						printf("Wrong physical address inserted!
\backslash
n");
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}						
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'i':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'i' option was passed the mandatory option 'g' */
\end_layout

\begin_layout Plain Layout

					if(mandatory_opt!=-1){
\end_layout

\begin_layout Plain Layout

						*r_w=READ; /* Set READ operation for GPIO */
\end_layout

\begin_layout Plain Layout

						i_or_o=1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'o':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'o' option was passed the mandatory option 'g' */
\end_layout

\begin_layout Plain Layout

					if(mandatory_opt!=-1){
\end_layout

\begin_layout Plain Layout

						*r_w=WRITE; /* Set WRITE operation for GPIO */
\end_layout

\begin_layout Plain Layout

						*value=strtoul(optarg, NULL, 0);
\end_layout

\begin_layout Plain Layout

						i_or_o=1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'h':
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return 1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case ':':
\end_layout

\begin_layout Plain Layout

					printf("Missing argument for '%c' option
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case '?':
\end_layout

\begin_layout Plain Layout

					printf("Option '%c' not recognized
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				default:
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

	/* Check if an i|o operation is requested */	
\end_layout

\begin_layout Plain Layout

	if(i_or_o==0){
\end_layout

\begin_layout Plain Layout

		printf("Can't use "BOLDWHITE"nodriver "RESET"without specify i|o option
\backslash
n");
\end_layout

\begin_layout Plain Layout

		usage(argv[0]);
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
open_memory
\end_layout

\begin_layout Standard
In questa funzione viene eseguita tutta la magia per poter accedere correttament
e ai registri della GPIO.
 Poichè il SO utilizza il meccanismo della virtualizzazione se si provasse
 ad accedere alla periferica direttamente con l'indirizzo fisico passato
 in ingresso al driver come attributo, molto probabilmente il SO resituirebbe
 un segmentation fault.
 Quello che bisogna fare è accedere ai registri tramite indirizzo virtuale,
 visto che è l'unico modo con cui è possibile comunicare con qualsiasi periferic
a.
 Il SO astrae, infatti, tutta la memoria.
 La funzione che consente di avere un indirizzo virtuale, dato un certo
 indirizzo fisico, è la system call 
\series bold
mmap
\series default
.
\end_layout

\begin_layout Standard
La prima cosa che si fa è accedere alla memoria tramite la system call 
\series bold
open
\series default
, andando a specificare di voler accedere sia in lettura sia scrittura.
 La memoria sotto Linux, viene vista come un qualsiasi file, la si accede
 tramite 
\shape italic
/dev/mem
\shape default
.
 Fatto ciò, attraverso un meccanismo di mascherazione, dall'indirizzo fisico
 viene estratto sia l'indirizzo fisico della pagina a cui è mappata la periferic
a, sia il suo offset (che poi è lo stesso anche per la pagina virtuale).
 
\end_layout

\begin_layout Standard
A questo punto, viene richiamata la mmap.
 Essendo il primo parametro NULL, allora è il Kernel a scegliere l'indirizzo
 a cui effettuare il mapping.
 Il secondo parametro, PAGE_SIZE, specifica la grandezza delle pagine viste
 dal SO; PROT_READ|PROT_WRITE indica che la pagine può essere letta e scritta.
 Il terzo parametro, MAP_SHARED, indica che le modifiche fatte al file sono
 condivise con gli altri processi mappati sulla stessa regione.
 
\shape italic
fd
\shape default
 è il descrittore che individua il file registri periferica; 
\shape italic
page_addr
\shape default
 è, invece, l'indirizzo fisico della pagina in cui si trova la periferica.
 Da qui, si capisce che la mmap accetta come indirizzo fisico solo un multiplo
 delle pagine utilizzate dal SO.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=114, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Opens /dev/mem file in order to access GPIO address and calculates
 page offset and virtual address of GPIO file.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	fd: file descriptor name.
\end_layout

\begin_layout Plain Layout

  * @param  [in] 	phy_address: GPIO's physical address.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	page_offset: page offset which GPIO finds.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	virtual_address: GPIO's virtual address.
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *         -1		An error occurred.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int open_memory(int* fd, int phy_address, int* page_offset,void** virtual_addres
s){
\end_layout

\begin_layout Plain Layout

	*fd = open ("/dev/mem", O_RDWR);
\end_layout

\begin_layout Plain Layout

		if (*fd < 1) {
\end_layout

\begin_layout Plain Layout

			perror("Error to open /dev/mem file");
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		int page_addr = phy_address & MASK_SIZE;
\end_layout

\begin_layout Plain Layout

		/* Calculates page offset */
\end_layout

\begin_layout Plain Layout

		*page_offset = phy_address - page_addr;
\end_layout

\begin_layout Plain Layout

		/* mmap system call returns virtual address of GPIO */
\end_layout

\begin_layout Plain Layout

		*virtual_address = mmap(NULL, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED,
 *fd, page_addr);
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
read_gpio
\end_layout

\begin_layout Standard
Legge il valore contenuto nella GPIO e restituisce un messaggio di avvenuta
 lettura.
 Si noti, che per eseguire correttamente l'operazione è stato aggiunto l'offset
 all'indirizzo virtuale che si ha a disposizione.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=137, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Reads the <value> in input to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	value: read value.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	virtual_address: GPIO's virtual address.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	page_offset: page offset which GPIO finds.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void read_gpio(int* value,void* virtual_address,int page_offset){
\end_layout

\begin_layout Plain Layout

	*value = *((unsigned *)(virtual_address + page_offset));
\end_layout

\begin_layout Plain Layout

	printf("The value on GPIO input is: %08x
\backslash
n",*value);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
write_gpio
\end_layout

\begin_layout Standard
Effettua la scrittura del valore passato al driver sulla periferica GPIO,
 stampando un messaggio di avvenuta scrittura.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=149, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Writes <value> in output to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	value: write value.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	phy_address: GPIO's physical address.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	virtual_address: GPIO's virtual address.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	page_offset: page offset which GPIO finds.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void write_gpio(int value,int phy_address,void* virtual_address, int page_offset
){
\end_layout

\begin_layout Plain Layout

	printf("Going to write onto %08x the value %08x
\backslash
n", phy_address, value );
\end_layout

\begin_layout Plain Layout

	*((unsigned *)(virtual_address + page_offset)) = value;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
close_memory
\end_layout

\begin_layout Standard
Chiude la memoria, aperta precedentemente, invocando la system call munmap,
 alla quale viene passato l'indirizzo virtuale del file aperto e la grandezza
 delle pagine.
 Infine, si richiama la close per chiudere il descrittore di file.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=162, caption="nodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Closes /dev/mem file.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	fd: file descriptor name.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	virtual_address: GPIO's virtual address.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void close_memory(int fd,void* virtual_address){
\end_layout

\begin_layout Plain Layout

	munmap(virtual_address,PAGE_SIZE);
\end_layout

\begin_layout Plain Layout

	close(fd);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
main.c
\end_layout

\begin_layout Standard
La funzione main è molto semplice.
 Dopo aver dichiarato una serie di variabili da passare alle funzioni, la
 prima operazione eseguita è verificare che la funzione adibita al parsing
 degli argomenti non restituisca nessun errore.
 Dopodichè si controlla che l'accesso in memoria non provochi errore.
 In funzione del valore della variabile 
\shape italic
r_or_w
\shape default
, quindi, viene richiamata la funzione di lettura o di scrittura.
 Infine, c'è la chiamata alla close_memory.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="main.c"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	main.c
\end_layout

\begin_layout Plain Layout

  * @authors	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	22-June-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	driver "nodriver" to control gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include "nodriver_header.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[]){
\end_layout

\begin_layout Plain Layout

	/*!< First step */
\end_layout

\begin_layout Plain Layout

	/*! Variables Declaration */
\end_layout

\begin_layout Plain Layout

	int file_descriptor; /* Memory file descriptor */
\end_layout

\begin_layout Plain Layout

	int r_w=READ;	/* Saves operation's type to do with GPIO */
\end_layout

\begin_layout Plain Layout

	int r_or_w_value = 0;	/* Saves read/write value from/on GPIO */
\end_layout

\begin_layout Plain Layout

	int ret_parse;	/* Returned value from parse_command function */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	unsigned phy_addr, page_off;	/* Respectively physical address of GPIO and
 page offset */
\end_layout

\begin_layout Plain Layout

	void *virt_addr;	/* Virtual address of GPIO */
\end_layout

\begin_layout Plain Layout

	/*!< Second step */
\end_layout

\begin_layout Plain Layout

	/*! parse_command function is called to parse all argument passed to driver
 nodriver */
\end_layout

\begin_layout Plain Layout

	/* Check if parse_command function returns error */
\end_layout

\begin_layout Plain Layout

	if((ret_parse=parse_command(argc,argv,&phy_addr,&r_w,&r_or_w_value))==1)
\end_layout

\begin_layout Plain Layout

		return 0;
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		if(ret_parse==-1)
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

	/*!< Third step */
\end_layout

\begin_layout Plain Layout

	/*! open_memory function is called to achieve gpio virtual address */
\end_layout

\begin_layout Plain Layout

	/* Check if open_memory function returns error */
\end_layout

\begin_layout Plain Layout

	if(open_memory(&file_descriptor,phy_addr,&page_off,&virt_addr)==-1){
\end_layout

\begin_layout Plain Layout

		printf("nodriver aborted!
\backslash
n");
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	//
\end_layout

\begin_layout Plain Layout

	/*!< Fourth step*/
\end_layout

\begin_layout Plain Layout

	/*! read_gpio is called if r_w variable is READ, otherwise is called write_gpio
 function */
\end_layout

\begin_layout Plain Layout

	if (r_w == READ) read_gpio(&r_or_w_value,virt_addr,page_off);
\end_layout

\begin_layout Plain Layout

	else write_gpio(r_or_w_value,phy_addr,virt_addr,page_off);
\end_layout

\begin_layout Plain Layout

	/*!< First step */
\end_layout

\begin_layout Plain Layout

	/*! close_memory function is called to close memory file and delete file
 descriptor */
\end_layout

\begin_layout Plain Layout

	close_memory(file_descriptor,virt_addr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
makefile
\end_layout

\begin_layout Standard
Per completezza, si riporta anche un semplice makefile realizzato per agevolare
 la fase di compilazione del driver, utilizzando la primitiva 
\family typewriter
make
\family default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=bash, caption="makefile"]
\end_layout

\begin_layout Plain Layout

nodriver : main.o nodriver_function.o
\end_layout

\begin_layout Plain Layout

	cc -o nodriver main.o nodriver_function.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main.o : main.c nodriver_function.c nodriver_header.h
\end_layout

\begin_layout Plain Layout

	cc -c main.c -o main.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

nodriver_function.o : nodriver_function.c nodriver_header.h
\end_layout

\begin_layout Plain Layout

	cc -c nodriver_function.c -o nodriver_function.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clean :
\end_layout

\begin_layout Plain Layout

	rm -f nodriver
\end_layout

\begin_layout Plain Layout

	rm *.o
\end_layout

\begin_layout Plain Layout

	echo "Clean all file!"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Esempio di esecuzione
\end_layout

\begin_layout Standard
In questa sezione viene mostrato come eseguire il driver appena scritto
 per pilotare led, switch e button della board Zybo.
 Per la buona riuscita di questa parte esercitativa, si precisa che è necessario
 essere riusciti a completare il booting da SD card, descritto nel capitolo
 precedente.
\end_layout

\begin_layout Standard
Per prima cosa, all'interno della partizione BOOT_F della SD card, si crea
 una cartella 
\shape italic
driver
\shape default
 al cui interno si andranno a mettere le 3 tipologie di driver richieste
 dalla traccia.
 Collegare la scheda al computer, aprire un terminale ed eseguire
\end_layout

\begin_layout Standard
\align center

\family typewriter
mkdir /media/daniele/BOOT_F/driver
\end_layout

\begin_layout Standard
digitare, infine, i comandi
\end_layout

\begin_layout Standard
\align center

\family typewriter
mkdir /media/daniele/BOOT_F/driver/nodriver 
\end_layout

\begin_layout Standard
\align center

\family typewriter
mkdir /media/daniele/BOOT_F/driver/uio 
\end_layout

\begin_layout Standard
\align center

\family typewriter
mkdir /media/daniele/BOOT_F/driver/uio_int 
\end_layout

\begin_layout Standard
per creare rispettivamente le cartelle in cui vanno inseriti il primo, secondo
 e terzo tipo di driver.
\end_layout

\begin_layout Standard
Si copiano, quindi, i file scritti all'interno della cartella corrispondente.
 Nel caso considerato il comando è
\end_layout

\begin_layout Standard
\align center

\family typewriter
cp -a Sistemi_Embedded/Esercitazione_7/Driver/0_noDriver/.
 /media/daniele/BOOT_F/driver/nodriver/
\end_layout

\begin_layout Standard
Eseguire l'operazione di umount delle partizioni
\end_layout

\begin_layout Standard
\align center

\family typewriter
umount /media/daniele/BOOT_F 
\end_layout

\begin_layout Standard
\align center

\family typewriter
umount /media/daniele/ROOT_FS 
\end_layout

\begin_layout Standard
Seguendo le indicazioni del precedente capitolo, si setta la board in modo
 tale da essere avviata via SD.
 Si apre un emulatore di terminale e si fa il reboot del SO.
\end_layout

\begin_layout Standard
Per prima, cosa si monta la partizione BOOT_F in 
\shape italic
/mnt
\end_layout

\begin_layout Standard
\align center

\family typewriter
mount /dev/mmcblk0p1 /mnt/
\end_layout

\begin_layout Standard
Con i comandi seguenti, si accede quindi alla cartella nella quale è stato
 caricato il driver
\end_layout

\begin_layout Standard
\align center

\family typewriter
cd /mnt/driver/nodriver
\end_layout

\begin_layout Standard
digitando 
\family typewriter
ls
\family default
 il risultato dovrebbe essere
\end_layout

\begin_layout Standard
\align center

\family typewriter
\color red
main.c makefile nodriver_function.c nodriver_header.h
\end_layout

\begin_layout Standard
Compiliamo il driver con la primitiva
\end_layout

\begin_layout Standard
\align center

\family typewriter
make
\end_layout

\begin_layout Standard
Per passare i giusti parametri al driver, bisogna conoscere gli esatti indirizzi
 delle periferiche GPIO che si vogliono pilotare.
 Di seguito, si suppone di voler pilotare bottoni, switch e led della board.
 Per la sintesi hardware, si rimanda alla descrizione fatta nel capitolo
 precedente, con l'unica eccezione di dover istanziare anzichè un'unica
 periferica, tre periferiche.
 Per conoscere l'esatto indirizzo a cui sono mappate, sempre in Vivado,
 aperto il block diagram, si apre la paletta 
\series bold
Address Editor
\series default
, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Address-Editor"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_0.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Address-Editor"

\end_inset

Address Editor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dove
\end_layout

\begin_layout Itemize
axi_gpio_0 è la GPIO associata ai bottoni;
\end_layout

\begin_layout Itemize
axi_gpio_1 è la GPIO associata agli switch;
\end_layout

\begin_layout Itemize
axi_gpio_2 è la GPIO associata ai led.
\end_layout

\begin_layout Standard
Nelle figure che seguono si riportano alcuni esempi di funzionamento, in
 particolare si mostra:
\end_layout

\begin_layout Itemize
una lettura sui button, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:button"

\end_inset

;
\end_layout

\begin_layout Itemize
una lettura sugli switch, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:switch"

\end_inset

;
\end_layout

\begin_layout Itemize
una scrittura sui led, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:led"

\end_inset

;
\end_layout

\begin_layout Itemize
il richiamo della funzione di help, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:usage"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_1.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:button"

\end_inset

Messaggio restituito dopo la pressione di BTN2(V16) e BTN3(Y16) 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_2.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:switch"

\end_inset

Messaggio restituito dopo aver alzato SW0(G15) e SW2(W13)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_3.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:led"

\end_inset

Messaggio restituito dopo che sulla board si sono accesi LD0(M14), LD1(M15)
 e LD2(G14)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_4.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:usage"

\end_inset

Usage function
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Seconda tipologia
\end_layout

\begin_layout Standard
Questa seconda tipologia di driver prevede che l'utente non debba conoscere
 necessariamente l'esatto indirizzo fisico della periferica GPIO a cui si
 vuole accedere.
 Infatti, poichè la periferica GPIO viene riconosciuta come un generico
 device uio, l'accesso ad essa è effettuato attraverso il file associato
 al device uio della GPIO, 
\shape italic
/dev/uiox
\shape default
.
 Si precisa che il driver di seguito sviluppato non fa utilizzo del meccanismo
 delle interruzioni.
\end_layout

\begin_layout Standard
Per garantire il funzionamento del driver è importante eseguire 2 cose:
\end_layout

\begin_layout Enumerate
Configurazione corretta del Kernel;
\end_layout

\begin_layout Enumerate
Modifica opportuna del device tree source.
\end_layout

\begin_layout Standard
Per ottemperare la prima delle due richieste, bisogna assicurarsi di aver
 abilitato l'utilizzo degli user space i/o driver all'interno della configurazio
ne del Kernel.
 Per far ciò all'interno della cartella di lavoro, creata nel capitolo predente,
 portarsi nella sottocartella contenente il kernel Linux
\end_layout

\begin_layout Standard
\align center

\family typewriter
cd Linux-Digilent-Dev/ 
\end_layout

\begin_layout Standard
e digitare
\end_layout

\begin_layout Standard
\align center

\family typewriter
make menuconfig
\end_layout

\begin_layout Standard
Nel menu di configurazione che si apre, accedere a 
\series bold
Device Drivers → Uerspace I/O drivers
\series default
 e assicurarsi di settare il kernel così come mostrato in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:uio"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_5.jpg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:uio"

\end_inset

Userspace I/O drivers
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inoltre, per via di un bug nella versione 3.18 del kernel Linux, bisogna
 entrare nella cartella 
\shape italic
Linux-Digilent-Dev/drivers/uio
\end_layout

\begin_layout Standard
\align center

\family typewriter
cd drivers/uio/
\end_layout

\begin_layout Standard
e dopo aver aperto il file 
\series bold
uio_pdrv_genirq.c
\end_layout

\begin_layout Standard
\align center

\family typewriter
gedit uio_pdrv_genirq.c
\end_layout

\begin_layout Standard
assicurarsi che alla riga 257 sia presente la stringa 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C]
\end_layout

\begin_layout Plain Layout

{ .compatible = "generic-uio", },
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
come evidenziato in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:uio_pdrv_genirq.c"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_6.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:uio_pdrv_genirq.c"

\end_inset

uio_pdrv_genirq.c
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per quanto riguarda invece la seconda richiesta, si fa utilizzo del tool
 SDK.
\end_layout

\begin_layout Standard
Prima di mostrare come operare, si fa una piccola precisazione.
 Nella prima tipologia di driver si utilizza direttamente l'indirizzo fisico
 della periferica, pertanto, se in una periferica GPIO Xilinx vengono sfruttati
 entrambi i canali, per accedervi basta fornire l'indirizzo del primo o
 secondo canale, in base a ciò che si è interessati.
 Poichè con questa seconda tipologia non si ha la possibilità di fornire
 un indirizzo fisico preciso, ma l'accesso alla periferica avviene solo
 tramite un indirizzo virtuale che punta alla prima locazione della periferica,
 l'accesso al primo o secondo canale deve essere fatto a livello driver.
 Il driver, che di seguito viene proposto, prevede, appunto, un meccanismo
 per garantire ciò.
 Per mostrare il completo funzionamento di esso, anzichè utilizzare lo stesso
 progetto hardware del precedente driver (3 GPIO diverse: una per i bottoni,
 ,una per gli switch e l'altra per i led), si crea un altro progetto, implementa
ndo solo 2 GPIO Xilinx.
 Sulla prima vengono mappati bottoni e switch, rispettivamente canale 1
 e 2 della periferica; sulla seconda, invece, vengono mappati i led della
 board.
 Per il procedimento, basta seguire le indicazioni fornite nel precedente
 capitolo e adattarle opportunamente alle specifiche di sopra.
 
\end_layout

\begin_layout Standard
Al termine della sintesi della parte hardware il block design dovrebbe essere
 come in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:block design"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_7.png
	lyxscale 80
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:block design"

\end_inset

Block Design
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come da prassi, si effettua nell'ordine il wrapper del componente, la sintesi,
 l'implementazione, il mapping dei porti, la generazione del bit stream
 e l'export del progetto, includendo il bitstream.
 A questo punto si lancia finalmente SDK.
\end_layout

\begin_layout Standard
Seguendo le indicazioni del capitolo precedente si crea prima il FSBL, poi
 il BOOT.bin e, infine, si fa generare al tool il device tree source.
\end_layout

\begin_layout Standard
Aprire il file 
\series bold
system-top.dts
\series default
 e modificarlo come in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:system-top.dts"

\end_inset

.
 Si noti che, rispetto al capitolo precedente, bisogna aggiungere il parametro
 evidenziato a causa del bug del kernel precedentemente citato.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_8.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:system-top.dts"

\end_inset

system-top.dts
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Modificare anche il file 
\series bold
pl.dts
\series default
, specificando nei campi 
\shape italic
compatible
\shape default
 delle due periferiche, axi_gpio_0 e axi_gpio_1, la stringa 
\begin_inset Quotes eld
\end_inset

generic-uio
\begin_inset Quotes erd
\end_inset

, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pl.dtsi"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_9.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pl.dtsi"

\end_inset

pl.dtsi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Arrivati a questo punto, si può finalmente generare il device tree blob
 da riga di comando, compilando il file system-top.dts.
\end_layout

\begin_layout Standard
Completata questa parte di configurazione, si descrivono adesso le principali
 differenze di questo driver rispetto a quello presentato precedentemente.
\end_layout

\begin_layout Subsubsection
uiodriver_header.h
\end_layout

\begin_layout Standard
Nell'header file si notano le macro relative agli offset dei registri GPIO_DATA
 e GPIO_TRI del primo canale e dei registri GPIO2_DATA e GPIO2_TRI del secondo
 canale della periferica AXI GPIO Xilinx.
 Inoltre, vengono definite 2 macro utilizzate proprio per tener traccia
 di quale dei due canali della periferica si vuole utilizzare.
 Per il resto, i prototipi delle funzioni sono gli stessi, eccetto qualche
 parametro aggiuntivo necessario per la gestione dei canali.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="uiodriver header.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	uiodriver_header.h
\end_layout

\begin_layout Plain Layout

  * @author	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	24-June-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	library 'uiodriver' for GPIO
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <unistd.h>
\end_layout

\begin_layout Plain Layout

#include <sys/mman.h>
\end_layout

\begin_layout Plain Layout

#include <fcntl.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Colour MACRO --------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define RESET		"
\backslash
033[0m"		/*!< Reset colour */
\end_layout

\begin_layout Plain Layout

#define GREEN   	"
\backslash
033[32m"     		/*!< Green colour */
\end_layout

\begin_layout Plain Layout

#define BOLDWHITE	"
\backslash
033[1m
\backslash
033[37m"	/*!< Bold White colour */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO operation MACRO ------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define READ 0					/*!< Read operation is set */
\end_layout

\begin_layout Plain Layout

#define WRITE 1					/*!< Write operation is set */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO page MACRO -----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define GPIO_MAP_SIZE 		0x10000		/*!< Bit mask to extract page address,
 without offset */
\end_layout

\begin_layout Plain Layout

#define GPIO_DATA_OFFSET	0x00		/*!< Offset of GPIO_DATA register */
\end_layout

\begin_layout Plain Layout

#define GPIO_TRI_OFFSET 	0x04		/*!< Offset of GPIO_TRI register */
\end_layout

\begin_layout Plain Layout

#define GPIO2_DATA_OFFSET 	0x08		/*!< Offset of GPIO2_DATA register */
\end_layout

\begin_layout Plain Layout

#define GPIO2_TRI_OFFSET 	0x0C		/*!< Offset of GPIO2_TRI register */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO channel MACRO --------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define GPIO_CHANNEL_1 1	/*!< GPIO channel 1 selected */
\end_layout

\begin_layout Plain Layout

#define GPIO_CHANNEL_2 2	/*!< GPIO channel 2 selected */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Function prototypes -------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void usage(char *name);/*!< usage function is called to help the user */
\end_layout

\begin_layout Plain Layout

int parse_command(int argc,char **argv,char** uiod,int* channel,int* r_w,int*
 value);/*!< parse_command function is called to parse arguments passed
 to driver */
\end_layout

\begin_layout Plain Layout

int open_device(int* fd, char* uiod, void** virtual_address);/*!< open_device
 function is called to open file associated to uio device */
\end_layout

\begin_layout Plain Layout

void read_gpio(int* value,void* virtual_address, int channel);/*!< read_gpio
 function is called to do read operation from GPIO */
\end_layout

\begin_layout Plain Layout

void write_gpio(int value,char* uiod,void* virtual_address, int channel);/*!<
 write_gpio function is called to do write operation on GPIO */
\end_layout

\begin_layout Plain Layout

void close_device(int fd, void* virtual_address);/*!< close_device function
 is called to close uio file */
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
uiodriver_function.h
\end_layout

\begin_layout Standard

\series bold
usage
\end_layout

\begin_layout Standard
La funzione resta pressappoco invariata, se non per il fatto che è stata
 aggiunta una nuova stringa da stampare a video per spiegare il corretto
 utilizzo del parametro 'c' per la selezione del canale da selezionare.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=14, caption="uiodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Describes how 'uiodriver' must be used, specifing all supported
 options.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	name: Specifies uiodriver name.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void usage(char *name){
\end_layout

\begin_layout Plain Layout

	printf("The right way to use this driver is
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"%s -d <UIO_DEV_FILE> -c <CHANNEL> -i|-o <VALUE>
\backslash
n"RESET,name);
\end_layout

\begin_layout Plain Layout

	printf("Please, pay attention:
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
t-d"RESET GREEN"
\backslash
t<UIO_DEV_FILE>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <UIO_DEV_FILE>
\backslash
n
\backslash
t
\backslash
tspecifies the uio device file corrisponding
\backslash
n
\backslash
t
\backslash
t to GPIO, for example /dev/uio0.
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-c"RESET GREEN"
\backslash
t<CHANNEL>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <CHANNEL> specify
\backslash
n
\backslash
t
\backslash
tthe GPIO channel to use 
\backslash
n
\backslash
t
\backslash
tThis number must be 1 or 2");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-i"RESET"
\backslash
n
\backslash
t
\backslash
tSpecifies the input value of GPIO 
\backslash
n
\backslash
t
\backslash
tcorrisponding to <UIO_DEV_FILE> 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-o"RESET GREEN"
\backslash
t<VALUE>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <VALUE> specify
\backslash
n
\backslash
t
\backslash
tthe value must be write on GPIO output 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
parse_command
\end_layout

\begin_layout Standard
Questa volta, all'interno della funzione, vengono dichiarate 2 variabili
 locali 
\series bold
man_opt_d
\series default
 e 
\series bold
man_opt_c
\series default
.
 Il loro scopo è di memorizzare se i parametri obbligatori 'd' e 'c' sono
 stati forniti in ingresso al driver.
 Ecco, allora, che se viene riconosciuto l'argomento 'c', viene controllato
 se precedentemente è stato fatto il parsing di 'd'.
 Meccanismo analogo viene replicato nei case 'i' e 'o' per controllare se
 precedentemente è stato fatto il parsing sia dell'argomento 'd', sia di
 quello 'c'.
 L'attributo che deve seguire l'argomento 'c' stabilisce quale dei due canali
 utilizzare, se il primo (1) o il secondo (2).
 Al termine della funzione oltre a controllare se è stata richiesta una
 delle due operazioni di lettura e scrittura, viene controllato anche se
 il numero fornito per selezionare il canale è corretto.
 Si noti, infine, che l'attributo di 'd' non è più un indirizzo fisico,
 ma il path dove si trova il file corrispondente al device uio.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=30, caption="uiodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Parses uiodriver arguments.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argc: number of parameters, passed to main function.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argv: parameters passed to main function
\end_layout

\begin_layout Plain Layout

  * @param  [out]	uiod: uio device file corrisponding to GPIO
\end_layout

\begin_layout Plain Layout

  * @param  [out]	channel: number corrisponding to GPIO channel
\end_layout

\begin_layout Plain Layout

  * @param  [out]	r_w: specifies if the operation on GPIO is a read or a
 write
\end_layout

\begin_layout Plain Layout

  * @param  [out]	value: contains the read value (if the operation on GPIO
 is a read) 
\end_layout

\begin_layout Plain Layout

  *		  	 or the value to write (if the operation on GPIO is a write)
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *         -1		An error occurred;
\end_layout

\begin_layout Plain Layout

  *	     1		Help function is called;		
\end_layout

\begin_layout Plain Layout

  * 	     0		Everything is ok.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int parse_command(int argc,char **argv,char** uiod,int* channel,int* r_w,int*
 value){
\end_layout

\begin_layout Plain Layout

	int index=0;
\end_layout

\begin_layout Plain Layout

	int man_opt_d=-1; 	/* Keep track if the mandatory option 'd' is parsed
 */
\end_layout

\begin_layout Plain Layout

	int man_opt_c=-1; 	/* Keep track if the mandatory option 'c' is parsed
 */
\end_layout

\begin_layout Plain Layout

	int i_or_o=0;		/* Keep track if an i|o operation is requested */
\end_layout

\begin_layout Plain Layout

	static char *optstring = ":d:c:io:h";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		while((index = getopt(argc, argv, optstring)) != -1) {
\end_layout

\begin_layout Plain Layout

				switch(index) {
\end_layout

\begin_layout Plain Layout

				case 'd':
\end_layout

\begin_layout Plain Layout

					man_opt_d=atoi(optarg);	/* Change mand_opt_d value to memorize that
 the option 'd' is parsed */
\end_layout

\begin_layout Plain Layout

					*uiod=optarg;						
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'c':
\end_layout

\begin_layout Plain Layout

					man_opt_c=atoi(optarg);	/* Change mand_opt_c value to memorize that
 the option 'c' is parsed */
\end_layout

\begin_layout Plain Layout

					/* Check if before 'c' option was passed the mandatory option 'd' */
\end_layout

\begin_layout Plain Layout

					if(man_opt_d!=-1){
\end_layout

\begin_layout Plain Layout

						*channel=atoi(optarg);
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'd'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'i':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'i' option was passed the mandatory option 'd' */
\end_layout

\begin_layout Plain Layout

					if(man_opt_d!=-1){
\end_layout

\begin_layout Plain Layout

						/* Check if before 'i' option was passed the mandatory option 'c'
 */
\end_layout

\begin_layout Plain Layout

						if(man_opt_c!=-1){
\end_layout

\begin_layout Plain Layout

							*r_w=READ; /* Set READ operation for GPIO */
\end_layout

\begin_layout Plain Layout

							i_or_o=1;
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

						else{
\end_layout

\begin_layout Plain Layout

							printf("Missing mandatory parameter 'c'
\backslash
n");
\end_layout

\begin_layout Plain Layout

							usage(argv[0]);
\end_layout

\begin_layout Plain Layout

							return -1;
\end_layout

\begin_layout Plain Layout

						}		
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'd'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'o':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'o' option was passed the mandatory option 'd' */
\end_layout

\begin_layout Plain Layout

					if(man_opt_d!=-1){
\end_layout

\begin_layout Plain Layout

						/* Check if before 'o' option was passed the mandatory option 'c'
 */
\end_layout

\begin_layout Plain Layout

						if(man_opt_c!=-1){
\end_layout

\begin_layout Plain Layout

							*r_w=WRITE; /* Set WRITE operation for GPIO */
\end_layout

\begin_layout Plain Layout

							*value=strtoul(optarg, NULL, 0);
\end_layout

\begin_layout Plain Layout

							i_or_o=1;
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

						else{
\end_layout

\begin_layout Plain Layout

							printf("Missing mandatory parameter 'c'
\backslash
n");
\end_layout

\begin_layout Plain Layout

							usage(argv[0]);
\end_layout

\begin_layout Plain Layout

							return -1;
\end_layout

\begin_layout Plain Layout

						}	
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'h':
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return 1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case ':':
\end_layout

\begin_layout Plain Layout

					printf("Missing argument for '%c' option
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case '?':
\end_layout

\begin_layout Plain Layout

					printf("Option '%c' not recognized
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				default:
\end_layout

\begin_layout Plain Layout

					usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

	/* Check if channel number is right*/
\end_layout

\begin_layout Plain Layout

	if(*channel!=GPIO_CHANNEL_1 && *channel!=GPIO_CHANNEL_2){
\end_layout

\begin_layout Plain Layout

		printf("Wrong channel number inserted
\backslash
n");
\end_layout

\begin_layout Plain Layout

		usage(argv[0]);
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	/* Check if an i|o operation is requested */	
\end_layout

\begin_layout Plain Layout

	if(i_or_o==0){
\end_layout

\begin_layout Plain Layout

		printf("Can't use "BOLDWHITE"uiodriver "RESET"without specify i|o option
\backslash
n");
\end_layout

\begin_layout Plain Layout

		usage(argv[0]);
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
open_device
\end_layout

\begin_layout Standard
Ha la stessa struttura della gemella open_memory.
 La sola differenza è che per generare l'indirizzo fisico non utilizza il
 descrittore di file associato al file dell'indirizzo di memoria, ma utilizza
 il descrittore associato al file del device uio.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=147, caption="uiodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Opens uio device file in order to access to it by its virtual
 address.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	fd: file descriptor name.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	uiod: uio device file corrisponding to GPIO.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	virtual_address: uio device file's virtual address.
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *         -1		An error occurred.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int open_device(int* fd, char* uiod, void** virtual_address){
\end_layout

\begin_layout Plain Layout

	*fd = open (uiod, O_RDWR);
\end_layout

\begin_layout Plain Layout

		if (*fd < 1) {
\end_layout

\begin_layout Plain Layout

			perror("Error to open uio device file");
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		/* mmap system call returns virtual address of <uiod> file */
\end_layout

\begin_layout Plain Layout

		*virtual_address = mmap(NULL, GPIO_MAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED,
 *fd, 0);
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
read_gpio
\end_layout

\begin_layout Standard
Nella funzione vengono dichiarate 2 variabili locali 
\series bold
gpio_tri_off
\series default
 e 
\series bold
gpio_data_off
\series default
.
 A tali variabili vengono assegnati i valori appropriati (richiamando le
 macro dichiarate) in base al valore di 
\series bold
channel
\series default
 che viene passato in ingresso alla funzione.
 Per il resto la lettura avviene così come nella prima tipologia di driver.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=166, caption="uiodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Reads the <value> in input to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	value: read value.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	virtual_address: uio device file's virtual address.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	channel: number corrisponding to GPIO channel
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void read_gpio(int* value,void* virtual_address,int channel){
\end_layout

\begin_layout Plain Layout

	/* Set the offsets to access to right gpio channel (1 or 2) */
\end_layout

\begin_layout Plain Layout

	int gpio_tri_off;
\end_layout

\begin_layout Plain Layout

	int gpio_data_off;
\end_layout

\begin_layout Plain Layout

	if(channel==GPIO_CHANNEL_1){
\end_layout

\begin_layout Plain Layout

		gpio_tri_off=GPIO_TRI_OFFSET;
\end_layout

\begin_layout Plain Layout

		gpio_data_off=GPIO_DATA_OFFSET;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else{
\end_layout

\begin_layout Plain Layout

		gpio_tri_off=GPIO2_TRI_OFFSET;
\end_layout

\begin_layout Plain Layout

		gpio_data_off=GPIO2_DATA_OFFSET;
\end_layout

\begin_layout Plain Layout

	}	
\end_layout

\begin_layout Plain Layout

	/* Set GPIO_TRI register values to configure the GPIO port as input */
\end_layout

\begin_layout Plain Layout

	*((unsigned *)(virtual_address + gpio_tri_off)) = 255;
\end_layout

\begin_layout Plain Layout

	/* Memorize the value from GPIO port in <value> */
\end_layout

\begin_layout Plain Layout

	*value = *((unsigned *)(virtual_address + gpio_data_off));
\end_layout

\begin_layout Plain Layout

	printf("The value on channel %d GPIO input is: %08x
\backslash
n",channel,*value);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
write_gpio
\end_layout

\begin_layout Standard
Il meccanismo di scrittura è simile al driver precedente.
 Anche qui viene usato lo stesso procedimento della funzione read_gpio per
 poter accedere correttamente al canale desiderato della periferica.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=192, caption="uiodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Writes <value> in output to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	value: write value.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	uiod: uio device file corrisponding to GPIO
\end_layout

\begin_layout Plain Layout

  * @param  [in]	virtual_address: uio device file's virtual address.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	channel: number corrisponding to GPIO channel
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void write_gpio(int value,char* uiod,void* virtual_address, int channel){
\end_layout

\begin_layout Plain Layout

	/* Set the offsets to access to right gpio channel (1 or 2) */
\end_layout

\begin_layout Plain Layout

	int gpio_tri_off;
\end_layout

\begin_layout Plain Layout

	int gpio_data_off;
\end_layout

\begin_layout Plain Layout

	if(channel==GPIO_CHANNEL_1){
\end_layout

\begin_layout Plain Layout

		gpio_tri_off=GPIO_TRI_OFFSET;
\end_layout

\begin_layout Plain Layout

		gpio_data_off=GPIO_DATA_OFFSET;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else{
\end_layout

\begin_layout Plain Layout

		gpio_tri_off=GPIO2_TRI_OFFSET;
\end_layout

\begin_layout Plain Layout

		gpio_data_off=GPIO2_DATA_OFFSET;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/* Set GPIO_TRI register values to configure the GPIO port as output */
\end_layout

\begin_layout Plain Layout

	*((unsigned *)(virtual_address + gpio_tri_off)) = 0;
\end_layout

\begin_layout Plain Layout

	printf("Value %08x is going to write onto %s (channel %d)
\backslash
n", value, uiod, channel);
\end_layout

\begin_layout Plain Layout

	/* Write <value> in GPIO register */
\end_layout

\begin_layout Plain Layout

	*((unsigned *)(virtual_address + gpio_data_off)) = value;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
close_device
\end_layout

\begin_layout Standard
La funzione è identica alla close_memory.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=219, caption="uiodriver function.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Closes /dev/uiox file.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	fd: file descriptor name of uio device
\end_layout

\begin_layout Plain Layout

  * @param  [in]	virtual_address: uio device's virtual address.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void close_device(int fd,void* virtual_address){
\end_layout

\begin_layout Plain Layout

	munmap(virtual_address,GPIO_MAP_SIZE);
\end_layout

\begin_layout Plain Layout

	close(fd);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
main.c
\end_layout

\begin_layout Standard
Anche il main è molto simile al precedente driver.
 In aggiunta, si ha la dichiarazione della variabile intera cha, in cui
 viene salvato il canale della periferica.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="main.c"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	uiodriver.c
\end_layout

\begin_layout Plain Layout

  * @authors	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	24-June-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	driver "uiodriver" to control gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include "uiodriver_header.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[]){
\end_layout

\begin_layout Plain Layout

	/*!< First step */
\end_layout

\begin_layout Plain Layout

	/*! Variables Declaration */
\end_layout

\begin_layout Plain Layout

	int file_descriptor; /* uio file descriptor */
\end_layout

\begin_layout Plain Layout

	int r_w=READ;	/* Saves operation's type to do with GPIO */
\end_layout

\begin_layout Plain Layout

	int r_or_w_value = 0;	/* Saves read/write value from/on GPIO */
\end_layout

\begin_layout Plain Layout

	int ret_parse;	/* Returned value from parse_command function */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	char* uio_dev;		/* uio device file name */
\end_layout

\begin_layout Plain Layout

	int cha;		/* channel number of GPIO */
\end_layout

\begin_layout Plain Layout

	void *virt_addr;	/* Virtual address of <uio_dev> */
\end_layout

\begin_layout Plain Layout

	/*!< Second step */
\end_layout

\begin_layout Plain Layout

	/*! parse_command function is called to parse all argument passed to driver
 uiodriver */
\end_layout

\begin_layout Plain Layout

	/* Check if parse_command function returns error */
\end_layout

\begin_layout Plain Layout

	if((ret_parse=parse_command(argc,argv,&uio_dev,&cha,&r_w,&r_or_w_value))==1)
\end_layout

\begin_layout Plain Layout

		return 0;
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		if(ret_parse==-1)
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

	/*!< Third step */
\end_layout

\begin_layout Plain Layout

	/*! open_device function is called to achieve gpio virtual address */
\end_layout

\begin_layout Plain Layout

	/* Check if open_device function returns error */
\end_layout

\begin_layout Plain Layout

	if(open_device(&file_descriptor,uio_dev,&virt_addr)==-1){
\end_layout

\begin_layout Plain Layout

		printf("nodriver aborted!
\backslash
n");
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	//
\end_layout

\begin_layout Plain Layout

	/*!< Fourth */
\end_layout

\begin_layout Plain Layout

	/*! read_gpio is called if r_w variable is READ, otherwise is called write_gpio
 function */
\end_layout

\begin_layout Plain Layout

	/* Calls conveniently read_gpio or write_gpio function */
\end_layout

\begin_layout Plain Layout

	if (r_w == READ) read_gpio(&r_or_w_value,virt_addr,cha);
\end_layout

\begin_layout Plain Layout

	else write_gpio(r_or_w_value,uio_dev,virt_addr,cha);
\end_layout

\begin_layout Plain Layout

	/*!< First step */
\end_layout

\begin_layout Plain Layout

	/*! close_device function is called to close device file and delete file
 descriptor */
\end_layout

\begin_layout Plain Layout

	close_device(file_descriptor,virt_addr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
makefile
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=bash, caption="makefile"]
\end_layout

\begin_layout Plain Layout

uiodriver : main.o uiodriver_function.o
\end_layout

\begin_layout Plain Layout

	cc -o uiodriver main.o uiodriver_function.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main.o : main.c uiodriver_function.c uiodriver_header.h
\end_layout

\begin_layout Plain Layout

	cc -c main.c -o main.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uiodriver_function.o : uiodriver_function.c uiodriver_header.h
\end_layout

\begin_layout Plain Layout

	cc -c uiodriver_function.c -o uiodriver_function.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clean :
\end_layout

\begin_layout Plain Layout

	rm -f uiodriver
\end_layout

\begin_layout Plain Layout

	rm *.o
\end_layout

\begin_layout Plain Layout

	echo "Clean all file!"
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Esempio di esecuzione
\end_layout

\begin_layout Standard
Come per il driver precedente, di seguito si si riportano alcuni esempi
 di funzionamento, in particolare si mostra:
\end_layout

\begin_layout Itemize
una lettura sui button, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:button-uio"

\end_inset

;
\end_layout

\begin_layout Itemize
una lettura sugli switch, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:switch-uio"

\end_inset

;
\end_layout

\begin_layout Itemize
una scrittura sui led, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:led-uio"

\end_inset

;
\end_layout

\begin_layout Itemize
il richiamo della funzione di help, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:usage-uio"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_10.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:button-uio"

\end_inset

Messaggio restituito dopo la pressione di BTN(V16) e BTN3(Y16) 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_11.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:switch-uio"

\end_inset

Messaggio restituito dopo aver alzato SW1(P15) e SW2(W13)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_12.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:led-uio"

\end_inset

Messaggio restituito dopo che sulla board si sono accesi LD0(M14), LD1(M15),
 LD2(G14) e LD3(D18)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_13.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:usage-uio"

\end_inset

Usage function
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Terza tipologia
\end_layout

\begin_layout Standard
Questa terza tipologia di driver è simile alla seconda, il device, infatti,
 viene acceduto mediante driver uio.
 La differenza con il precedente sta nell'utilizzo del meccanismo delle
 interruzioni.
\end_layout

\begin_layout Standard
A partire dalla sintesi hardware del precedente driver, si aggiunge ad ogni
 periferica GPIO l'abilitazione a funzionare con le interruzioni.
 Per far ciò si rimanda alla guida nel precedente capitolo.
 Il block design risultante dovrebbe essere simile a quello descritto in
 fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:block design 3"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_15.png
	lyxscale 80
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:block design 3"

\end_inset

Block Design
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si nota che è stato aggiunto il componente 
\series bold
concat
\series default
 per il corretto instradamento delle linee di interruzione.
 Facendo doppio click sul componente, si impostano il numero di porti da
 voler utilizzare, fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:concat"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_14.png
	lyxscale 80
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:concat"

\end_inset

Concat customization
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dopo aver generato il bitstream e aver lanciato SDK, si eseguono le stesse
 procedure di modifica descritte precedentemente al fine di rendere la periferic
a compatibile con i driver uio.
 Questa volta, nel file pl.dts, sono comparsi altri campi che descrivono
 come verranno gestite le interruzioni del componente.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=bash, caption="pl.dts"]
\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

 * CAUTION: This file is automatically generated by Xilinx.
\end_layout

\begin_layout Plain Layout

 * Version:  
\end_layout

\begin_layout Plain Layout

 * Today is: Sun Jul  9 20:39:39 2017
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/ {
\end_layout

\begin_layout Plain Layout

	amba_pl: amba_pl {
\end_layout

\begin_layout Plain Layout

		#address-cells = <1>;
\end_layout

\begin_layout Plain Layout

		#size-cells = <1>;
\end_layout

\begin_layout Plain Layout

		compatible = "simple-bus";
\end_layout

\begin_layout Plain Layout

		ranges ;
\end_layout

\begin_layout Plain Layout

		axi_gpio_0: gpio@41200000 {
\end_layout

\begin_layout Plain Layout

			#gpio-cells = <2>;
\end_layout

\begin_layout Plain Layout

			#interrupt-cells = <2>;
\end_layout

\begin_layout Plain Layout

			compatible = "generic-uio";
\end_layout

\begin_layout Plain Layout

			gpio-controller ;
\end_layout

\begin_layout Plain Layout

			interrupt-controller ;
\end_layout

\begin_layout Plain Layout

			interrupt-parent = <&intc>;
\end_layout

\begin_layout Plain Layout

			interrupts = <0 30 4>;
\end_layout

\begin_layout Plain Layout

			reg = <0x41200000 0x10000>;
\end_layout

\begin_layout Plain Layout

			xlnx,all-inputs = <0x1>;
\end_layout

\begin_layout Plain Layout

			xlnx,all-inputs-2 = <0x1>;
\end_layout

\begin_layout Plain Layout

			xlnx,all-outputs = <0x0>;
\end_layout

\begin_layout Plain Layout

			xlnx,all-outputs-2 = <0x0>;
\end_layout

\begin_layout Plain Layout

			xlnx,dout-default = <0x00000000>;
\end_layout

\begin_layout Plain Layout

			xlnx,dout-default-2 = <0x00000000>;
\end_layout

\begin_layout Plain Layout

			xlnx,gpio-width = <0x4>;
\end_layout

\begin_layout Plain Layout

			xlnx,gpio2-width = <0x4>;
\end_layout

\begin_layout Plain Layout

			xlnx,interrupt-present = <0x1>;
\end_layout

\begin_layout Plain Layout

			xlnx,is-dual = <0x1>;
\end_layout

\begin_layout Plain Layout

			xlnx,tri-default = <0xFFFFFFFF>;
\end_layout

\begin_layout Plain Layout

			xlnx,tri-default-2 = <0xFFFFFFFF>;
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

		axi_gpio_1: gpio@41210000 {
\end_layout

\begin_layout Plain Layout

			#gpio-cells = <2>;
\end_layout

\begin_layout Plain Layout

			#interrupt-cells = <2>;
\end_layout

\begin_layout Plain Layout

			compatible = "generic-uio";
\end_layout

\begin_layout Plain Layout

			gpio-controller ;
\end_layout

\begin_layout Plain Layout

			interrupt-controller ;
\end_layout

\begin_layout Plain Layout

			interrupt-parent = <&intc>;
\end_layout

\begin_layout Plain Layout

			interrupts = <0 29 4>;
\end_layout

\begin_layout Plain Layout

			reg = <0x41210000 0x10000>;
\end_layout

\begin_layout Plain Layout

			xlnx,all-inputs = <0x0>;
\end_layout

\begin_layout Plain Layout

			xlnx,all-inputs-2 = <0x0>;
\end_layout

\begin_layout Plain Layout

			xlnx,all-outputs = <0x1>;
\end_layout

\begin_layout Plain Layout

			xlnx,all-outputs-2 = <0x0>;
\end_layout

\begin_layout Plain Layout

			xlnx,dout-default = <0x00000000>;
\end_layout

\begin_layout Plain Layout

			xlnx,dout-default-2 = <0x00000000>;
\end_layout

\begin_layout Plain Layout

			xlnx,gpio-width = <0x4>;
\end_layout

\begin_layout Plain Layout

			xlnx,gpio2-width = <0x20>;
\end_layout

\begin_layout Plain Layout

			xlnx,interrupt-present = <0x1>;
\end_layout

\begin_layout Plain Layout

			xlnx,is-dual = <0x0>;
\end_layout

\begin_layout Plain Layout

			xlnx,tri-default = <0xFFFFFFFF>;
\end_layout

\begin_layout Plain Layout

			xlnx,tri-default-2 = <0xFFFFFFFF>;
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In particolare, nel campo 
\family typewriter
interrupt-parent
\family default
 viene definito il controller delle interruzioni.
 Prendendo in esempio l'axi_gpio_1, i valori <0 29 4> del campo 
\family typewriter
interrupts
\family default
 significano:
\end_layout

\begin_layout Itemize
0 - l'interruzione non è SPI, altrimenti ci sarebbe stato 1;
\end_layout

\begin_layout Itemize
29 - è il numero dell'interruzione gestita dal GIC a cui bisogna sommare
 il valore 32.
 Se fosse stata un'interruzione SPI, si sarebbe sommato 16.
\end_layout

\begin_layout Itemize
4 - l'interruzione viene presa in carico sui livelli alti del segnale.
 (1 per i rising edge; 2 falling edge; 8 livello basso).
\end_layout

\begin_layout Subsubsection
uiointdriver_header.h
\end_layout

\begin_layout Standard
In questo header file, rispetto a quello del driver precedente, si noti
 che è stata ampliata la parte riguardante le macro relative ai registri
 della GPIO.
 Sono state aggiunte GPIO_GIER_OFFSET, GPIO_IP_ISR_OFFSET e GPIO_IP_IER_OFFSET
 che individuano, rispettivamente, gli offset dei registri Global Interrupt
 Enable Register, Interrupt Status Register e Interrupt Enable Register.
 Sono state aggiunte anche delle maschere per l'abilitazione e la disabilitazion
e di tali registri, tenendo conto delle specifiche descritte nella documentazion
e della GPIO Xilinx, 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-
axi-gpio.pdf
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=bash, caption="uiointdriver header"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	uiointdriver_header.h
\end_layout

\begin_layout Plain Layout

  * @author	Colella Gianni - Guida Ciro - Lombardi Daniele
\end_layout

\begin_layout Plain Layout

  *		Group IV - Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	2-July-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	library 'uiointdriver' for GPIO
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <stdint.h>
\end_layout

\begin_layout Plain Layout

#include <unistd.h>
\end_layout

\begin_layout Plain Layout

#include <sys/mman.h>
\end_layout

\begin_layout Plain Layout

#include <fcntl.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

#include <sys/types.h>
\end_layout

\begin_layout Plain Layout

#include <sys/stat.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Colour MACRO --------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define RESET		"
\backslash
033[0m"		/*!< Reset colour */
\end_layout

\begin_layout Plain Layout

#define GREEN   	"
\backslash
033[32m"     		/*!< Green colour */
\end_layout

\begin_layout Plain Layout

#define BOLDWHITE	"
\backslash
033[1m
\backslash
033[37m"	/*!< Bold White colour */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO operation MACRO ------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define READ 0					/*!< Read operation is set */
\end_layout

\begin_layout Plain Layout

#define WRITE 1					/*!< Write operation is set */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO page MACRO -----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define GPIO_MAP_SIZE 		0x10000		/*!< Bit mask to extract page address,
 without offset */
\end_layout

\begin_layout Plain Layout

#define GPIO_DATA_OFFSET	0x00		/*!< Offset of GPIO_DATA register */
\end_layout

\begin_layout Plain Layout

#define GPIO_TRI_OFFSET 	0x04		/*!< Offset of GPIO_TRI register */
\end_layout

\begin_layout Plain Layout

#define GPIO2_DATA_OFFSET 	0x08		/*!< Offset of GPIO2_DATA register */
\end_layout

\begin_layout Plain Layout

#define GPIO2_TRI_OFFSET 	0x0C		/*!< Offset of GPIO2_TRI register */
\end_layout

\begin_layout Plain Layout

#define GPIO_GIER_OFFSET	0x11C 		/*!< Offset of Glogal interrupt enable
 register */
\end_layout

\begin_layout Plain Layout

#define GPIO_IP_ISR_OFFSET	0x120 		/*!< Offset of IP Interrupt status register
 */
\end_layout

\begin_layout Plain Layout

#define GPIO_IP_IER_OFFSET	0x128 		/*!< Offset of IP Interrupt enable register
 */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO enable/disable mask --------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define GPIO_GIER_DISABLE	0x00000000	/*!< GPIO Global Interrupt disable
 mask */
\end_layout

\begin_layout Plain Layout

#define CHANNEL_1_IER_DISABLE	0x00000000	/*!< GPIO Channel 1 Interrupt disable
 mask */
\end_layout

\begin_layout Plain Layout

#define CHANNEL_2_IER_DISABLE 	0x00000000	/*!< GPIO Channel 2 Interrupt
 disable mask */
\end_layout

\begin_layout Plain Layout

#define GPIO_GIER_ENABLE 	0x80000000	/*!< GPIO Global Interrupt enable mask
 */
\end_layout

\begin_layout Plain Layout

#define CHANNEL_1_IER_ENABLE 	0x00000001	/*!< GPIO Channel 1 Interrupt enable
 mask */
\end_layout

\begin_layout Plain Layout

#define CHANNEL_2_IER_ENABLE 	0x00000002	/*!< GPIO Channel 2 Interrupt enable
 mask */
\end_layout

\begin_layout Plain Layout

#define CHANNEL_1_ISR	 	0x00000001	/*!< GPIO Channel 1 ISR mask */
\end_layout

\begin_layout Plain Layout

#define CHANNEL_2_ISR	 	0x00000002	/*!< GPIO Channel 2 ISR mask */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO channel MACRO --------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define GPIO_CHANNEL_1 1	/*!< GPIO channel 1 selected */
\end_layout

\begin_layout Plain Layout

#define GPIO_CHANNEL_2 2	/*!< GPIO channel 2 selected */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Function prototypes -------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void usage(char *name); /*!< usage function is called to help the user */
\end_layout

\begin_layout Plain Layout

int parse_command(int argc,char **argv,char** uiod,int* channel,int* r_w,int*
 value);/*!< parse_command function is called to parse arguments passed
 to driver */
\end_layout

\begin_layout Plain Layout

int open_device(int* fd, char* uiod, void** virtual_address);/*!< open_device
 function is called to open file associated to uio device */
\end_layout

\begin_layout Plain Layout

int read_gpio(int fd,int* value,char* uiod, void* virtual_address, int channel);
/*!< read_gpio function is called to do read operation from GPIO */
\end_layout

\begin_layout Plain Layout

void write_gpio(int value,char* uiod,void* virtual_address, int channel);/*!<
 write_gpio function is called to do write operation on GPIO */
\end_layout

\begin_layout Plain Layout

void close_device(int fd,void* virtual_address);/*!< close_device function
 is called to close uio file */
\end_layout

\begin_layout Plain Layout

int GPIO_Interrupt(long* base_add,int reg, unsigned long mask); /*!Set/reset
 Gpio registers in order to handle interrupts */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
uiointdriver_function.h
\end_layout

\begin_layout Standard
Di seguito si descrive l'unica funzione variata rispetto al driver precedente.
\end_layout

\begin_layout Standard

\series bold
read_gpio
\end_layout

\begin_layout Standard
Questa funzione è il cuore del driver uiointdriver.
 Innazitutto, si osservi che sono state aggiunte una serie di variabili
 in più rispetto alla omonima funzione del precedente driver.
 Le variabili 
\series bold
num_byte
\series default
 e 
\series bold
test_read
\series default
 servono rispettivamente per tenere traccia del numero di byte letti dalla
 successiva operazione di read ed il contenuto di tale operazione.
 Servono unicamente come controllo.
 Alle variabili 
\series bold
gpio_tri_off
\series default
 e 
\series bold
gpio_data_off
\series default
, si sono aggiunte 
\series bold
gpio_cha_interrupt_en
\series default
, 
\series bold
gpio_cha_interrupt_dis
\series default
 e 
\series bold
gpio_cha_isr
\series default
.
 L'utilizzo è il medesimo, in base al valore del canale selezionate queste
 variabili assumeranno un certo valore che servirà per eseguire opportunamente
 le operazioni o sul canale 1 oppure sul 2.
 
\end_layout

\begin_layout Standard
Dopo aver settato la modalità di funzionamento del GPIO in lettura, semmai
 non fosse già stata predisposta, il driver entra in un ciclo infinito in
 cui legge il valore presente sul GPIO ogni volta che si scatena un'interruzione.
 
\end_layout

\begin_layout Standard
Il primo passo compiuto è quello di abilitare le interruzioni, pertanto,
 prima viene settato il bit 31 del registro GIER, poi, successivamente viene
 abilitato anche il bit del registro IPIER, rispettando il canale che si
 vuole utilizzare.
 Abilitate le periferiche, il processo si sospende sulla periferica, in
 attesa di essere svegliato dall'arrivo di un'interruzione.
 Una volta svegliato, viene effettuato un controllo per stabilire se l'operazion
e di read ha generato qualche problema, utilizzando le variabili di cui
 sopra.
 A questo punto, dopo aver disabilitato sia l'interruzione globale, sia
 quella del canale in oggetto, viene effettuata l'operazione di read sul
 registro data della GPIO.
 Se si decommenta il while al rigo 231, si induce il processo ad arrestarsi
 fintanto che il segnale che ha generato l'interruzione non si riporta ad
 un livello basso, che è quello di default.
 In altre parole, il processo non effettua più alcuna lettura finchè lo
 switch o il bottone non vengono rilasciati.
 Successivamente, sempre previo controllo, viene fatto un clean dell'interruzion
e, in modo che il SO possa ripristinare la linea di interruzione della periferic
a.
 Infine, viene inviato un ack alla periferica per comunicarle di essere
 stata servita.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=bash, firstnumber=166, caption="uiointdriver
 header.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Reads the <value> in input to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	fd: file descriptor name.
\end_layout

\begin_layout Plain Layout

  * @param  [out]	value: read value.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	uiod: uio device file corrisponding to GPIO
\end_layout

\begin_layout Plain Layout

  * @param  [in]	virtual_address: uio device file's virtual address.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	channel: number corrisponding to GPIO channel
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int read_gpio(int fd,int* value,char* uiod, void* virtual_address, int channel){
\end_layout

\begin_layout Plain Layout

	/* number of bytes read */
\end_layout

\begin_layout Plain Layout

	ssize_t num_byte;
\end_layout

\begin_layout Plain Layout

	/* to test if read operation is correct */
\end_layout

\begin_layout Plain Layout

	uint32_t test_read=1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* Set the offsets to access to right gpio channel (1 or 2) */
\end_layout

\begin_layout Plain Layout

	int gpio_tri_off;
\end_layout

\begin_layout Plain Layout

	int gpio_data_off;
\end_layout

\begin_layout Plain Layout

	unsigned long gpio_cha_interrupt_en;
\end_layout

\begin_layout Plain Layout

	unsigned long gpio_cha_interrupt_dis;
\end_layout

\begin_layout Plain Layout

	unsigned long gpio_cha_isr;
\end_layout

\begin_layout Plain Layout

	if(channel==GPIO_CHANNEL_1){
\end_layout

\begin_layout Plain Layout

		gpio_tri_off=GPIO_TRI_OFFSET;
\end_layout

\begin_layout Plain Layout

		gpio_data_off=GPIO_DATA_OFFSET;
\end_layout

\begin_layout Plain Layout

		gpio_cha_interrupt_en=CHANNEL_1_IER_ENABLE;
\end_layout

\begin_layout Plain Layout

		gpio_cha_interrupt_dis=CHANNEL_1_IER_DISABLE;
\end_layout

\begin_layout Plain Layout

		gpio_cha_isr=CHANNEL_1_ISR;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else{
\end_layout

\begin_layout Plain Layout

		gpio_tri_off=GPIO2_TRI_OFFSET;
\end_layout

\begin_layout Plain Layout

		gpio_data_off=GPIO2_DATA_OFFSET;
\end_layout

\begin_layout Plain Layout

		gpio_cha_interrupt_en=CHANNEL_2_IER_ENABLE;
\end_layout

\begin_layout Plain Layout

		gpio_cha_interrupt_dis=CHANNEL_2_IER_DISABLE;
\end_layout

\begin_layout Plain Layout

		gpio_cha_isr=CHANNEL_2_ISR;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/*----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* Set GPIO_TRI register values to configure the GPIO port as input */
\end_layout

\begin_layout Plain Layout

	*((unsigned *)(virtual_address + gpio_tri_off)) = 255;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while(1){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		/* Enable Global Interrupt of GPIO */
\end_layout

\begin_layout Plain Layout

		GPIO_Interrupt(virtual_address,GPIO_GIER_OFFSET,GPIO_GIER_ENABLE);
\end_layout

\begin_layout Plain Layout

		/* Enable Channel Interrut of GPIO */
\end_layout

\begin_layout Plain Layout

		GPIO_Interrupt(virtual_address,GPIO_IP_IER_OFFSET,gpio_cha_interrupt_en);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		/* to suspend the process on gpio peripheral */
\end_layout

\begin_layout Plain Layout

		num_byte=read(fd,&test_read,sizeof(test_read));
\end_layout

\begin_layout Plain Layout

		if(num_byte!=sizeof(test_read)){
\end_layout

\begin_layout Plain Layout

			printf("It occurs an error on read opeartion
\backslash
n");
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else{
\end_layout

\begin_layout Plain Layout

			/* Disable Global Interrupt of GPIO */
\end_layout

\begin_layout Plain Layout

			GPIO_Interrupt(virtual_address,GPIO_GIER_OFFSET,GPIO_GIER_DISABLE);
\end_layout

\begin_layout Plain Layout

			/* Disable Channel Interrut of GPIO */
\end_layout

\begin_layout Plain Layout

			GPIO_Interrupt(virtual_address,GPIO_IP_IER_OFFSET,gpio_cha_interrupt_dis);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

			/* Memorize the value from GPIO port in <value> */
\end_layout

\begin_layout Plain Layout

			*value = *((unsigned *)(virtual_address + gpio_data_off));
\end_layout

\begin_layout Plain Layout

			printf("The value on channel %d of %s input is: %08x
\backslash
n",channel,uiod,*value);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

/* In this case the driver don't read the register until the input that
 cause the interrupt is set to default low position */
\end_layout

\begin_layout Plain Layout

//		while(*((unsigned *)(virtual_address + gpio_data_off))!=0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		/* test reenable interrupt */
\end_layout

\begin_layout Plain Layout

		ssize_t re_enable = 1;
\end_layout

\begin_layout Plain Layout

		/* to clean interrupt */
\end_layout

\begin_layout Plain Layout

		re_enable = write(fd, &re_enable, sizeof(re_enable)); 
\end_layout

\begin_layout Plain Layout

		if (re_enable < sizeof(re_enable)) {
\end_layout

\begin_layout Plain Layout

			perror("write");
\end_layout

\begin_layout Plain Layout

			close(fd);
\end_layout

\begin_layout Plain Layout

			exit(EXIT_FAILURE);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		/* Sent ack to GPIO peripheral */
\end_layout

\begin_layout Plain Layout

		GPIO_Interrupt(virtual_address, GPIO_IP_ISR_OFFSET, gpio_cha_isr);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
GPIO_Interrupt
\end_layout

\begin_layout Standard
Questa funzione, in base al valore di reg passatole, viene utilizzata per
 modificare il contenuto dei registri della GPIO, adibiti al controllo delle
 interruzioni.
 In particolare, il nuovo valore da assumere viene passato attraverso 
\series bold
mask
\series default
, come unsigned long.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, firstnumber=288, caption="uiointdriver function"]
\end_layout

\begin_layout Plain Layout

/**   
\end_layout

\begin_layout Plain Layout

* @brief  According to the offset <reg>, modifies the values of enable registers
 of GPIO custom peripheral   
\end_layout

\begin_layout Plain Layout

* @param  [in]	base_add: virtual base address of GPIO peripheral   
\end_layout

\begin_layout Plain Layout

* @param  [in]	reg: offset value of selected register   
\end_layout

\begin_layout Plain Layout

* @param  [in]	mask: register value   
\end_layout

\begin_layout Plain Layout

* @retval 1.
   
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

int GPIO_Interrupt(long* base_add,int reg, unsigned long mask)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	*((unsigned *)(base_add + (reg/4)))=mask;	
\end_layout

\begin_layout Plain Layout

	return 1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
main.c
\end_layout

\begin_layout Standard
Il main del driver è praticamente identico al precedente.
\end_layout

\begin_layout Subsubsection
makefile
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=bash, caption="makefile"]
\end_layout

\begin_layout Plain Layout

uiodriver : main.o uiointdriver_function.o
\end_layout

\begin_layout Plain Layout

	cc -o uiointdriver main.o uiointdriver_function.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main.o : main.c uiointdriver_function.c uiointdriver_header.h
\end_layout

\begin_layout Plain Layout

	cc -c main.c -o main.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uiointdriver_function.o : uiointdriver_function.c uiointdriver_header.h
\end_layout

\begin_layout Plain Layout

	cc -c uiointdriver_function.c -o uiointdriver_function.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clean :
\end_layout

\begin_layout Plain Layout

	rm -f uiointdriver
\end_layout

\begin_layout Plain Layout

	rm *.o
\end_layout

\begin_layout Plain Layout

	echo "Clean all file!"
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Esempio di esecuzione
\end_layout

\begin_layout Standard
Di seguito, si mostra un esempio di esecuzione del driver in cui si sceglie
 di leggere dalla periferica GPIO mappata sugli switch della board Zybo,
 fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:read"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_16.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:read"

\end_inset

Read operation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Procedimento: GPIO custom
\end_layout

\begin_layout Standard
Come si evince dalla traccia, in questa sezione si fa riferimento alla GPIO
 custom sviluppata nel Capitolo 1 di questa documentazione.
 In generale, le funzioni utilizzate dal driver sono praticamente analoghe
 a quelle viste nella precedente sezione, fatta eccezione per il fatto che
 si deve tener conto della diversa struttura interna della periferica, in
 particolar modo della locazione dei vari registri.
 Per non ripetersi nella trattazione, di seguito sono riportati semplicemente
 i codici utilizzati.
 In più, quando i codici non presentano grosse differenze tra una tipologia
 e l'altra del codice, sono omessi.
\end_layout

\begin_layout Subsection
Prima tipologia
\end_layout

\begin_layout Standard
Di seguito si mostra il design project di riferimento in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:design project gpio custom"

\end_inset

, mentre in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:base address periferiche"

\end_inset

 sono mostrati i base address delle periferiche utilizzate.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_17.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:design project gpio custom"

\end_inset

Design project GPIO custom
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_18.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:base address periferiche"

\end_inset

Base address periferiche
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
mygpio_nodriver.h
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="mygpio nodriver.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	mygpio_nodriver.h
\end_layout

\begin_layout Plain Layout

  * @author	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	7-July-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	library mygpio_nodriver gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <unistd.h>
\end_layout

\begin_layout Plain Layout

#include <sys/mman.h>
\end_layout

\begin_layout Plain Layout

#include <fcntl.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

#include "gpio_custom.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Data Structure to manage data associated to GPIO custom peripheral
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

typedef struct{
\end_layout

\begin_layout Plain Layout

	gpio_custom_TypeDef* gpio_custom;	/*!< Contains virtual address (page offset
 included) and offset registers value of GPIO */
\end_layout

\begin_layout Plain Layout

	int gpio_phy_address;			/*!< Physical address of GPIO */
\end_layout

\begin_layout Plain Layout

	int fd;					/*!< Memory file descriptor */
\end_layout

\begin_layout Plain Layout

	int r_w;				/*!< Saves operation's type to do with GPIO */
\end_layout

\begin_layout Plain Layout

	uint32_t r_or_w_value;			/*!< Saves read/write value from/on GPIO */
\end_layout

\begin_layout Plain Layout

}mygpio_TypeDef;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO port MACRO -----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define GPIO_PORT 0xF 				/*!< GPIO ports selected to read/write */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Colour MACRO --------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define RESET		"
\backslash
033[0m"		/*!< Reset colour */
\end_layout

\begin_layout Plain Layout

#define GREEN   	"
\backslash
033[32m"     		/*!< Green colour */
\end_layout

\begin_layout Plain Layout

#define BOLDWHITE	"
\backslash
033[1m
\backslash
033[37m"	/*!< Bold White colour */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO operation MACRO ------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define READ 	1				/*!< Read operation is set */
\end_layout

\begin_layout Plain Layout

#define WRITE 	0				/*!< Write operation is set */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO page MACRO -----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define PAGE_SIZE sysconf(_SC_PAGESIZE) 	/*!< Page size used by SO */
\end_layout

\begin_layout Plain Layout

#define MASK_SIZE (~(PAGE_SIZE-1))		/*!< Bit mask to extract page address,
 without offset */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Function prototypes -------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void mygpio_usage(char *name); /*!< usage function is called to help the
 user */
\end_layout

\begin_layout Plain Layout

int mygpio_parse_command(int argc,char **argv,mygpio_TypeDef* mygpio);	/*!<
 parse_command function is called to parse arguments passed to driver */
\end_layout

\begin_layout Plain Layout

int mygpio_open_memory(mygpio_TypeDef* mygpio);	/*!< mygpio_open_memory
 function is called to open memory file */
\end_layout

\begin_layout Plain Layout

void mygpio_read_gpio(mygpio_TypeDef* mygpio); 	/*!< mygpio_read_gpio function
 is called to do read operation from GPIO */
\end_layout

\begin_layout Plain Layout

void mygpio_write_gpio(mygpio_TypeDef* mygpio); /*!< mygpio_write_gpio function
 is called to do write operation on GPIO */
\end_layout

\begin_layout Plain Layout

void mygpio_close_memory(mygpio_TypeDef* mygpio);/*!< mygpio_close_memory
 function is called to close memory file */
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
mygpio_nodriver.h
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="mygpio nodriver.c"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	mygpio_nodriver.c
\end_layout

\begin_layout Plain Layout

  * @authors	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	7-July-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	Functions used for mygpio_nodriver gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include "mygpio_nodriver.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Describes how 'mygpio_nodriver' must be used, specifing all
 supported options.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	name: Specifies mygpio_nodriver name.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_usage(char *name){
\end_layout

\begin_layout Plain Layout

	printf("The right way to use this driver is
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"%s -g <GPIO_ADDRESS> -i|-o <VALUE>
\backslash
n"RESET,name);
\end_layout

\begin_layout Plain Layout

	printf("Please, pay attention:
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
t-g"RESET GREEN"
\backslash
t<GPIO_ADDR>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <GPIO_ADDR>
\backslash
n
\backslash
t
\backslash
tspecifies the physical address of GPIO.
\backslash
n
\backslash
t
\backslash
t<GPIO_ADDR> can be expressed in
\backslash
n
\backslash
t
\backslash
tdecimal representation (no prefix),
\backslash
n
\backslash
t
\backslash
toctal representation (0 prefix)
\backslash
n
\backslash
t
\backslash
tor hexadecimal representation
\backslash
n
\backslash
t
\backslash
t(0x or 0X prefix)
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-i"RESET"
\backslash
n
\backslash
t
\backslash
tSpecifies the input value of GPIO at
\backslash
n
\backslash
t
\backslash
t<GPIO_ADDR> physical address 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-o"RESET GREEN"
\backslash
t<VALUE>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <VALUE> specify
\backslash
n
\backslash
t
\backslash
tthe value must be write on GPIO output 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Parses nodriver arguments.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argc: number of parameters, passed to main function.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argv: parameters passed to main function
\end_layout

\begin_layout Plain Layout

  * @param  [out] 	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *	    -1		An error occurred;
\end_layout

\begin_layout Plain Layout

  *	     1		Help function is called;		
\end_layout

\begin_layout Plain Layout

  * 	     0		Everything is ok.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int mygpio_parse_command(int argc,char **argv,mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	int index=0;
\end_layout

\begin_layout Plain Layout

	int mandatory_opt=-1; 			/* Keep track if the mandatory option 'g' is parsed
 */
\end_layout

\begin_layout Plain Layout

	int i_or_o=0;				/* Keep track if an i|o operation is requested */
\end_layout

\begin_layout Plain Layout

	static char *optstring = ":g:io:h";	/* Allowed parameters */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		while((index = getopt(argc, argv, optstring)) != -1) {
\end_layout

\begin_layout Plain Layout

				switch(index) {
\end_layout

\begin_layout Plain Layout

				case 'g':
\end_layout

\begin_layout Plain Layout

					mandatory_opt=atoi(optarg);	/* Change mandatory_opt value to memorize
 that the mandatory option is parsed */
\end_layout

\begin_layout Plain Layout

					mygpio->gpio_phy_address=strtoul(optarg,NULL, 0);
\end_layout

\begin_layout Plain Layout

					/* Check if address passed is not 0x0 */
\end_layout

\begin_layout Plain Layout

					if(mygpio->gpio_phy_address==0){
\end_layout

\begin_layout Plain Layout

						printf("Wrong physical address inserted!
\backslash
n");
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}						
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'i':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'i' option was passed the mandatory option 'g' */
\end_layout

\begin_layout Plain Layout

					if(mandatory_opt!=-1){
\end_layout

\begin_layout Plain Layout

						mygpio->r_w=READ; /* Set READ operation for GPIO */
\end_layout

\begin_layout Plain Layout

						i_or_o=1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'o':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'o' option was passed the mandatory option 'g' */
\end_layout

\begin_layout Plain Layout

					if(mandatory_opt!=-1){
\end_layout

\begin_layout Plain Layout

						mygpio->r_w=WRITE; /* Set WRITE operation for GPIO */
\end_layout

\begin_layout Plain Layout

						mygpio->r_or_w_value=strtoul(optarg, NULL, 0);
\end_layout

\begin_layout Plain Layout

						i_or_o=1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'h':
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return 1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case ':':
\end_layout

\begin_layout Plain Layout

					printf("Missing argument for '%c' option
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case '?':
\end_layout

\begin_layout Plain Layout

					printf("Option '%c' not recognized
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				default:
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

	/* Check if an i|o operation is requested */	
\end_layout

\begin_layout Plain Layout

	if(i_or_o==0){
\end_layout

\begin_layout Plain Layout

		printf("Can't use "BOLDWHITE"nodriver "RESET"without specify i|o option
\backslash
n");
\end_layout

\begin_layout Plain Layout

		mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Opens /dev/mem file in order to access custom GPIO address and
 calculates page offset and virtual address of GPIO file.
\end_layout

\begin_layout Plain Layout

  * @param  [inout]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *         -1		An error occurred.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int mygpio_open_memory(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	mygpio->fd = open ("/dev/mem", O_RDWR);
\end_layout

\begin_layout Plain Layout

		if (mygpio->fd < 1) {
\end_layout

\begin_layout Plain Layout

			perror("Error to open /dev/mem file");
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		int page_phy_addr = (mygpio->gpio_phy_address) & MASK_SIZE;
\end_layout

\begin_layout Plain Layout

		printf("page_phy_addr %d
\backslash
n",page_phy_addr); //debug
\end_layout

\begin_layout Plain Layout

		/* Calculates page offset */
\end_layout

\begin_layout Plain Layout

		off_t page_offset = (off_t)((mygpio->gpio_phy_address) - page_phy_addr);
\end_layout

\begin_layout Plain Layout

		printf("page_offset %lu
\backslash
n",page_offset); //debug
\end_layout

\begin_layout Plain Layout

		/* mmap system call returns virtual page address of GPIO */
\end_layout

\begin_layout Plain Layout

		void* vrt_add = mmap(NULL, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED,
 mygpio->fd, page_phy_addr);
\end_layout

\begin_layout Plain Layout

		mygpio->gpio_custom->base_address=vrt_add + page_offset; // base address
 includes page offset
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Reads the <mygpio->r_or_w_value> in input to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [inout]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_read_gpio(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetEnable(mygpio->gpio_custom, GPIO_PORT, HIGH);
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetMode(mygpio->gpio_custom, GPIO_PORT, READ);
\end_layout

\begin_layout Plain Layout

	mygpio->r_or_w_value=gpio_custom_GetValue(mygpio->gpio_custom,GPIO_PORT);
\end_layout

\begin_layout Plain Layout

	printf("The value on GPIO %08x input is: %08x
\backslash
n",mygpio->gpio_phy_address,mygpio->r_or_w_value);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Writes <mygpio->r_or_w_value> in output to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [inout]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_write_gpio(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetEnable(mygpio->gpio_custom, GPIO_PORT, HIGH);
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetMode(mygpio->gpio_custom, GPIO_PORT, WRITE);
\end_layout

\begin_layout Plain Layout

	printf("Going to write onto GPIO %08x the value %08x
\backslash
n", mygpio->gpio_phy_address, mygpio->r_or_w_value);
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetValue(mygpio->gpio_custom, GPIO_PORT, LOW);
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetValue(mygpio->gpio_custom, mygpio->r_or_w_value, HIGH);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Closes /dev/mem file.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_close_memory(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	munmap((void*)(mygpio->gpio_custom->base_address),PAGE_SIZE);
\end_layout

\begin_layout Plain Layout

	close(mygpio->fd);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
main.c
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="main.c"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	main.c
\end_layout

\begin_layout Plain Layout

  * @authors	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	4-July-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	driver "mygpio_nodriver" to control gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include "mygpio_nodriver.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[]){
\end_layout

\begin_layout Plain Layout

	/*!< First step */
\end_layout

\begin_layout Plain Layout

	/*! Structure and variable declaration */
\end_layout

\begin_layout Plain Layout

	mygpio_TypeDef mygpio; /* Structure associated to GPIO custom peripheral
 */
\end_layout

\begin_layout Plain Layout

	int ret_parse;		/* Returned value from mygpio_parse_command function */
\end_layout

\begin_layout Plain Layout

	/*!< Second step */
\end_layout

\begin_layout Plain Layout

	/*! mygpio_parse_command function is called to parse all argument passed
 to driver mygpio_nodriver */
\end_layout

\begin_layout Plain Layout

	/* Check if mygpio_parse_command function returns error */
\end_layout

\begin_layout Plain Layout

	if((ret_parse=mygpio_parse_command(argc,argv,&mygpio))==1)
\end_layout

\begin_layout Plain Layout

		return 0;
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		if(ret_parse==-1)
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	/*!< Third step */
\end_layout

\begin_layout Plain Layout

	/*! open_memory function is called to achieve gpio virtual address */
\end_layout

\begin_layout Plain Layout

	/* Check if mygpio_open_memory function returns error */
\end_layout

\begin_layout Plain Layout

	if(mygpio_open_memory(&mygpio)==-1){
\end_layout

\begin_layout Plain Layout

		printf("nodriver aborted!
\backslash
n");
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	//
\end_layout

\begin_layout Plain Layout

	/*!< Fourth step*/
\end_layout

\begin_layout Plain Layout

	/*! mygpio_read_gpio is called if r_w variable is READ, otherwise is called
 write_gpio function */
\end_layout

\begin_layout Plain Layout

	if ((mygpio.r_w) == READ) mygpio_read_gpio(&mygpio);
\end_layout

\begin_layout Plain Layout

	else mygpio_write_gpio(&mygpio);
\end_layout

\begin_layout Plain Layout

	/*!< First step */
\end_layout

\begin_layout Plain Layout

	/*! mygpio_close_memory function is called to close memory file and delete
 file descriptor */
\end_layout

\begin_layout Plain Layout

	mygpio_close_memory(&mygpio);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
makefile
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=bash, caption="makefile"]
\end_layout

\begin_layout Plain Layout

mygpio_nodriver : main.o mygpio_nodriver.o gpio_custom.o
\end_layout

\begin_layout Plain Layout

	cc -o mygpio_nodriver main.o mygpio_nodriver.o gpio_custom.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main.o : main.c mygpio_nodriver.c gpio_custom.c mygpio_nodriver.h gpio_custom.h
\end_layout

\begin_layout Plain Layout

	cc -c main.c -o main.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mygpio_nodriver.o : mygpio_nodriver.c mygpio_nodriver.h gpio_custom.h
\end_layout

\begin_layout Plain Layout

	cc -c mygpio_nodriver.c -o mygpio_nodriver.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

gpio_custom.o : gpio_custom.c gpio_custom.h
\end_layout

\begin_layout Plain Layout

	cc -c gpio_custom.c -o gpio_custom.o
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clean :
\end_layout

\begin_layout Plain Layout

	rm -f mygpio_nodriver
\end_layout

\begin_layout Plain Layout

	rm *.o
\end_layout

\begin_layout Plain Layout

	echo "Clean all file!"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Seconda tipologia
\end_layout

\begin_layout Standard
Il design project e i base address sono i medesimi della tipologia precedente.
\end_layout

\begin_layout Subsubsection
mygpio_uiodriver.h
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="mygpio uiodriver.h"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	mygpio_uiodriver.h
\end_layout

\begin_layout Plain Layout

  * @author	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	7-July-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	library mygpio_uiodriver gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <unistd.h>
\end_layout

\begin_layout Plain Layout

#include <sys/mman.h>
\end_layout

\begin_layout Plain Layout

#include <fcntl.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

#include "gpio_custom.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Data Structure to manage data associated to GPIO custom peripheral
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

typedef struct{
\end_layout

\begin_layout Plain Layout

	gpio_custom_TypeDef* gpio_custom;	/*!< Contains virtual address (page offset
 included) and offset registers value of GPIO device uio*/
\end_layout

\begin_layout Plain Layout

	char* uiod;				/*!< uio device file corrisponding to GPIO */
\end_layout

\begin_layout Plain Layout

	int fd;					/*!< Memory file descriptor */
\end_layout

\begin_layout Plain Layout

	int r_w;				/*!< Saves operation's type to do with GPIO */
\end_layout

\begin_layout Plain Layout

	uint32_t r_or_w_value;			/*!< Saves read/write value from/on GPIO */
\end_layout

\begin_layout Plain Layout

}mygpio_TypeDef;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO port MACRO -----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define GPIO_PORT 0xF 				/*!< GPIO ports selected to read/write */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Colour MACRO --------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define RESET		"
\backslash
033[0m"		/*!< Reset colour */
\end_layout

\begin_layout Plain Layout

#define GREEN   	"
\backslash
033[32m"     		/*!< Green colour */
\end_layout

\begin_layout Plain Layout

#define BOLDWHITE	"
\backslash
033[1m
\backslash
033[37m"	/*!< Bold White colour */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO operation MACRO ------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define READ 	1				/*!< Read operation is set */
\end_layout

\begin_layout Plain Layout

#define WRITE 	0				/*!< Write operation is set */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* GPIO page MACRO -----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#define PAGE_SIZE sysconf(_SC_PAGESIZE) 	/*!< Page size used by SO */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Function prototypes -------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void mygpio_usage(char *name); /*!< usage function is called to help the
 user */
\end_layout

\begin_layout Plain Layout

int mygpio_parse_command(int argc,char **argv,mygpio_TypeDef* mygpio);	/*!<
 parse_command function is called to parse arguments passed to driver */
\end_layout

\begin_layout Plain Layout

int mygpio_open_memory(mygpio_TypeDef* mygpio);	/*!< mygpio_open_memory
 function is called to open memory file */
\end_layout

\begin_layout Plain Layout

void mygpio_read_gpio(mygpio_TypeDef* mygpio); 	/*!< mygpio_read_gpio function
 is called to do read operation from GPIO */
\end_layout

\begin_layout Plain Layout

void mygpio_write_gpio(mygpio_TypeDef* mygpio); /*!< mygpio_write_gpio function
 is called to do write operation on GPIO */
\end_layout

\begin_layout Plain Layout

void mygpio_close_memory(mygpio_TypeDef* mygpio);/*!< mygpio_close_memory
 function is called to close memory file */
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
mygpio_uiodriver.c
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="mygpio uiodriver.c"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	mygpio_uiodriver.c
\end_layout

\begin_layout Plain Layout

  * @authors	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	7-July-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	Functions used for mygpio_uiodriver gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include "mygpio_uiodriver.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Describes how 'mygpio_uiodriver' must be used, specifing all
 supported options.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	name: Specifies mygpio_nodriver name.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_usage(char *name){
\end_layout

\begin_layout Plain Layout

	printf("The right way to use this driver is
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"%s -d <UIO_DEV_FILE> -i|-o <VALUE>
\backslash
n"RESET,name);
\end_layout

\begin_layout Plain Layout

	printf("Please, pay attention:
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
t-d"RESET GREEN"
\backslash
t<UIO_DEV_FILE>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <UIO_DEV_FILE>
\backslash
n
\backslash
t
\backslash
tspecifies the uio device file corrisponding
\backslash
n
\backslash
t
\backslash
t to GPIO, for example /dev/uio0.
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-i"RESET"
\backslash
n
\backslash
t
\backslash
tSpecifies the input value of GPIO 
\backslash
n
\backslash
t
\backslash
tcorrisponding to <UIO_DEV_FILE> 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-o"RESET GREEN"
\backslash
t<VALUE>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <VALUE> specify
\backslash
n
\backslash
t
\backslash
tthe value must be write on GPIO output 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Parses mygpio_uiodriver arguments.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argc: number of parameters, passed to main function.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argv: parameters passed to main function
\end_layout

\begin_layout Plain Layout

  * @param  [out] 	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *	    -1		An error occurred;
\end_layout

\begin_layout Plain Layout

  *	     1		Help function is called;		
\end_layout

\begin_layout Plain Layout

  * 	     0		Everything is ok.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int mygpio_parse_command(int argc,char **argv,mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	int index=0;
\end_layout

\begin_layout Plain Layout

	int mandatory_opt=-1; 			/* Keep track if the mandatory option 'g' is parsed
 */
\end_layout

\begin_layout Plain Layout

	int i_or_o=0;				/* Keep track if an i|o operation is requested */
\end_layout

\begin_layout Plain Layout

	static char *optstring = ":d:io:h";	/* Allowed parameters */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		while((index = getopt(argc, argv, optstring)) != -1) {
\end_layout

\begin_layout Plain Layout

				switch(index) {
\end_layout

\begin_layout Plain Layout

				case 'd':
\end_layout

\begin_layout Plain Layout

					mandatory_opt=atoi(optarg);	/* Change mandatory_opt value to memorize
 that the mandatory option is parsed */
\end_layout

\begin_layout Plain Layout

					mygpio->uiod=optarg;		/* Saves device uio path name */					
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'i':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'i' option was passed the mandatory option 'g' */
\end_layout

\begin_layout Plain Layout

					if(mandatory_opt!=-1){
\end_layout

\begin_layout Plain Layout

						mygpio->r_w=READ; /* Set READ operation for GPIO */
\end_layout

\begin_layout Plain Layout

						i_or_o=1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'o':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'o' option was passed the mandatory option 'g' */
\end_layout

\begin_layout Plain Layout

					if(mandatory_opt!=-1){
\end_layout

\begin_layout Plain Layout

						mygpio->r_w=WRITE; /* Set WRITE operation for GPIO */
\end_layout

\begin_layout Plain Layout

						mygpio->r_or_w_value=strtoul(optarg, NULL, 0);
\end_layout

\begin_layout Plain Layout

						i_or_o=1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'h':
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return 1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case ':':
\end_layout

\begin_layout Plain Layout

					printf("Missing argument for '%c' option
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case '?':
\end_layout

\begin_layout Plain Layout

					printf("Option '%c' not recognized
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				default:
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

	/* Check if an i|o operation is requested */	
\end_layout

\begin_layout Plain Layout

	if(i_or_o==0){
\end_layout

\begin_layout Plain Layout

		printf("Can't use "BOLDWHITE"nodriver "RESET"without specify i|o option
\backslash
n");
\end_layout

\begin_layout Plain Layout

		mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Opens /dev/mem file in order to access custom GPIO address and
 calculates page offset and virtual address of GPIO file.
\end_layout

\begin_layout Plain Layout

  * @param  [inout]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *         -1		An error occurred.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int mygpio_open_memory(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	mygpio->fd = open (mygpio->uiod, O_RDWR);
\end_layout

\begin_layout Plain Layout

		if (mygpio->fd < 1) {
\end_layout

\begin_layout Plain Layout

			perror("Error to open uio device file");
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		/* mmap system call returns virtual page address of GPIO device uio */
\end_layout

\begin_layout Plain Layout

		void* vrt_add = mmap(NULL, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED,
 mygpio->fd, 0);
\end_layout

\begin_layout Plain Layout

		mygpio->gpio_custom->base_address=vrt_add; // virtual base address extracted
 from mmap
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Reads the <mygpio->r_or_w_value> in input to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [inout]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_read_gpio(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetEnable(mygpio->gpio_custom, GPIO_PORT, HIGH);
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetMode(mygpio->gpio_custom, GPIO_PORT, READ);
\end_layout

\begin_layout Plain Layout

	mygpio->r_or_w_value=gpio_custom_GetValue(mygpio->gpio_custom,GPIO_PORT);
\end_layout

\begin_layout Plain Layout

	printf("The value on GPIO %s input is: %08x
\backslash
n",mygpio->uiod,mygpio->r_or_w_value);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Writes <mygpio->r_or_w_value> in output to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [inout]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_write_gpio(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	printf("Debug: do l'abiliazione al gpio
\backslash
n");
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetEnable(mygpio->gpio_custom, GPIO_PORT, HIGH);
\end_layout

\begin_layout Plain Layout

	printf("Debug: dico al gpio che è in scrittura
\backslash
n");
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetMode(mygpio->gpio_custom, GPIO_PORT, WRITE);
\end_layout

\begin_layout Plain Layout

	printf("Going to write onto GPIO %s the value %08x
\backslash
n", mygpio->uiod, mygpio->r_or_w_value);
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetValue(mygpio->gpio_custom, GPIO_PORT, LOW);  // Cleans previous
 values
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetValue(mygpio->gpio_custom, mygpio->r_or_w_value, HIGH);
\end_layout

\begin_layout Plain Layout

	printf("Debug: ho finito di scrivere
\backslash
n");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Closes /dev/mem file.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_close_memory(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	munmap((void*)(mygpio->gpio_custom->base_address),PAGE_SIZE);
\end_layout

\begin_layout Plain Layout

	close(mygpio->fd);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
main.c
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="main.c"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	main.c
\end_layout

\begin_layout Plain Layout

  * @authors	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	5-July-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	driver "mygpio_uiodriver" to control gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include "mygpio_uiodriver.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[]){
\end_layout

\begin_layout Plain Layout

	printf("debug 1
\backslash
n");
\end_layout

\begin_layout Plain Layout

	/*!< First step */
\end_layout

\begin_layout Plain Layout

	/*! Structure and variable declaration */
\end_layout

\begin_layout Plain Layout

	mygpio_TypeDef mygpio; /* Structure associated to GPIO custom peripheral
 */
\end_layout

\begin_layout Plain Layout

	int ret_parse;		/* Returned value from mygpio_parse_command function */
\end_layout

\begin_layout Plain Layout

	printf("debug 2
\backslash
n");
\end_layout

\begin_layout Plain Layout

	/*!< Second step */
\end_layout

\begin_layout Plain Layout

	/*! mygpio_parse_command function is called to parse all argument passed
 to driver mygpio_uiodriver */
\end_layout

\begin_layout Plain Layout

	/* Check if mygpio_parse_command function returns error */
\end_layout

\begin_layout Plain Layout

	if((ret_parse=mygpio_parse_command(argc,argv,&mygpio))==1)
\end_layout

\begin_layout Plain Layout

		return 0;
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		if(ret_parse==-1)
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	printf("debug 3
\backslash
n");
\end_layout

\begin_layout Plain Layout

	/*!< Third step */
\end_layout

\begin_layout Plain Layout

	/*! mygpio_open_memory function is called to achieve gpio virtual address
 */
\end_layout

\begin_layout Plain Layout

	/* Check if mygpio_open_memory function returns error */
\end_layout

\begin_layout Plain Layout

	if(mygpio_open_memory(&mygpio)==-1){
\end_layout

\begin_layout Plain Layout

		printf("nodriver aborted!
\backslash
n");
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	//
\end_layout

\begin_layout Plain Layout

	/*!< Fourth step*/
\end_layout

\begin_layout Plain Layout

	/*! mygpio_read_gpio is called if r_w variable is READ, otherwise is called
 write_gpio function */
\end_layout

\begin_layout Plain Layout

	if ((mygpio.r_w) == READ) mygpio_read_gpio(&mygpio);
\end_layout

\begin_layout Plain Layout

	else mygpio_write_gpio(&mygpio);
\end_layout

\begin_layout Plain Layout

	/*!< First step */
\end_layout

\begin_layout Plain Layout

	/*! mygpio_close_memory function is called to close memory file and delete
 file descriptor */
\end_layout

\begin_layout Plain Layout

	mygpio_close_memory(&mygpio);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Terza tipologia
\end_layout

\begin_layout Standard
In fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:design gpio custom con inter"

\end_inset

 si osserva il design project di riferimento, mentre i base address sono
 identici alle altre due tipologie di driver.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Img_19.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:design gpio custom con inter"

\end_inset

Design project GPIO custom con interrupt
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
mygpio_uiointdriver.c
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C, caption="mygpio uiointdriver.c"]
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

  * @file    	mygpio_uiointdriver.c
\end_layout

\begin_layout Plain Layout

  * @authors	Colella Gianni - Guida Ciro - Lombardi Daniele / Group IV -
 Sistemi Embedded 2016-2017
\end_layout

\begin_layout Plain Layout

  * @version 	V1.0
\end_layout

\begin_layout Plain Layout

  * @date    	7-July-2017
\end_layout

\begin_layout Plain Layout

  * @brief   	Functions used for mygpio_uiointdriver gpio
\end_layout

\begin_layout Plain Layout

  ******************************************************************************
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Includes ------------------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

#include "mygpio_uiointdriver.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Describes how 'mygpio_uiodriver' must be used, specifing all
 supported options.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	name: Specifies mygpio_nodriver name.
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_usage(char *name){
\end_layout

\begin_layout Plain Layout

	printf("The right way to use this driver is
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"%s -d <UIO_DEV_FILE> -i|-o <VALUE>
\backslash
n"RESET,name);
\end_layout

\begin_layout Plain Layout

	printf("Please, pay attention:
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
t-d"RESET GREEN"
\backslash
t<UIO_DEV_FILE>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <UIO_DEV_FILE>
\backslash
n
\backslash
t
\backslash
tspecifies the uio device file corrisponding
\backslash
n
\backslash
t
\backslash
t to GPIO, for example /dev/uio0.
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-i"RESET"
\backslash
n
\backslash
t
\backslash
tSpecifies the input value of GPIO 
\backslash
n
\backslash
t
\backslash
tcorrisponding to <UIO_DEV_FILE> 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	printf(BOLDWHITE"
\backslash
n
\backslash
t-o"RESET GREEN"
\backslash
t<VALUE>"RESET"
\backslash
n
\backslash
t
\backslash
tThe mandatory parameter <VALUE> specify
\backslash
n
\backslash
t
\backslash
tthe value must be write on GPIO output 
\backslash
n");
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Parses nodriver arguments.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argc: number of parameters, passed to main function.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	argv: parameters passed to main function
\end_layout

\begin_layout Plain Layout

  * @param  [out] 	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *	    -1		An error occurred;
\end_layout

\begin_layout Plain Layout

  *	     1		Help function is called;		
\end_layout

\begin_layout Plain Layout

  * 	     0		Everything is ok.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int mygpio_parse_command(int argc,char **argv,mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	int index=0;
\end_layout

\begin_layout Plain Layout

	int mandatory_opt=-1; 			/* Keep track if the mandatory option 'g' is parsed
 */
\end_layout

\begin_layout Plain Layout

	int i_or_o=0;				/* Keep track if an i|o operation is requested */
\end_layout

\begin_layout Plain Layout

	static char *optstring = ":d:io:h";	/* Allowed parameters */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		while((index = getopt(argc, argv, optstring)) != -1) {
\end_layout

\begin_layout Plain Layout

				switch(index) {
\end_layout

\begin_layout Plain Layout

				case 'd':
\end_layout

\begin_layout Plain Layout

					mandatory_opt=atoi(optarg);	/* Change mandatory_opt value to memorize
 that the mandatory option is parsed */
\end_layout

\begin_layout Plain Layout

					mygpio->uiod=optarg;		/* Saves device uio path name */					
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'i':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'i' option was passed the mandatory option 'g' */
\end_layout

\begin_layout Plain Layout

					if(mandatory_opt!=-1){
\end_layout

\begin_layout Plain Layout

						mygpio->r_w=READ; /* Set READ operation for GPIO */
\end_layout

\begin_layout Plain Layout

						i_or_o=1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'o':
\end_layout

\begin_layout Plain Layout

					/* Check if before 'o' option was passed the mandatory option 'g' */
\end_layout

\begin_layout Plain Layout

					if(mandatory_opt!=-1){
\end_layout

\begin_layout Plain Layout

						mygpio->r_w=WRITE; /* Set WRITE operation for GPIO */
\end_layout

\begin_layout Plain Layout

						mygpio->r_or_w_value=strtoul(optarg, NULL, 0);
\end_layout

\begin_layout Plain Layout

						i_or_o=1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else{
\end_layout

\begin_layout Plain Layout

						printf("Missing mandatory parameter 'g'
\backslash
n");
\end_layout

\begin_layout Plain Layout

						mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

						return -1;
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 'h':
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return 1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case ':':
\end_layout

\begin_layout Plain Layout

					printf("Missing argument for '%c' option
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case '?':
\end_layout

\begin_layout Plain Layout

					printf("Option '%c' not recognized
\backslash
n", optopt);
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				default:
\end_layout

\begin_layout Plain Layout

					mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

					return -1;
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

	/* Check if an i|o operation is requested */	
\end_layout

\begin_layout Plain Layout

	if(i_or_o==0){
\end_layout

\begin_layout Plain Layout

		printf("Can't use "BOLDWHITE"nodriver "RESET"without specify i|o option
\backslash
n");
\end_layout

\begin_layout Plain Layout

		mygpio_usage(argv[0]);
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Opens /dev/mem file in order to access custom GPIO address and
 calculates page offset and virtual address of GPIO file.
\end_layout

\begin_layout Plain Layout

  * @param  [inout]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval Integer status:
\end_layout

\begin_layout Plain Layout

  *         -1		An error occurred.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int mygpio_open_memory(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	mygpio->fd = open (mygpio->uiod, O_RDWR);
\end_layout

\begin_layout Plain Layout

		if (mygpio->fd < 1) {
\end_layout

\begin_layout Plain Layout

			perror("Error to open uio device file");
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		/* mmap system call returns virtual page address of GPIO device uio */
\end_layout

\begin_layout Plain Layout

		void* vrt_add = mmap(NULL, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED,
 mygpio->fd, 0);
\end_layout

\begin_layout Plain Layout

		mygpio->gpio_custom->base_address=vrt_add; // virtual base address extracted
 from mmap
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Reads the <mygpio->r_or_w_value> in input to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [inout]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

int mygpio_read_gpio(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* number of bytes read */
\end_layout

\begin_layout Plain Layout

	ssize_t num_byte;
\end_layout

\begin_layout Plain Layout

	/* to test if read operation is correct */
\end_layout

\begin_layout Plain Layout

	uint32_t test_read=1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* Set PAD_EN register to enable read operation from GPIO port */
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetEnable(mygpio->gpio_custom, GPIO_PORT, HIGH);
\end_layout

\begin_layout Plain Layout

	/* Set PAD_RW_N register of GPIO to configure the GPIO port as input */	
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetMode(mygpio->gpio_custom, GPIO_PORT, READ);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while(1){
\end_layout

\begin_layout Plain Layout

		/* Enable Global Interrupt of GPIO */
\end_layout

\begin_layout Plain Layout

		gpio_custom_SetGlobalInterrupt(mygpio->gpio_custom, HIGH);
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		/* Enable Interrupt on all port of GPIO*/		
\end_layout

\begin_layout Plain Layout

		gpio_custom_SetInterruptMask(mygpio->gpio_custom, GPIO_PORT, HIGH);		
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		/* to suspend the process on GPIO peripheral */
\end_layout

\begin_layout Plain Layout

		num_byte=read(mygpio->fd,&test_read,sizeof(test_read));
\end_layout

\begin_layout Plain Layout

		if(num_byte!=sizeof(test_read)){
\end_layout

\begin_layout Plain Layout

			printf("It occurs an error on read opeartion
\backslash
n");
\end_layout

\begin_layout Plain Layout

			return -1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else{
\end_layout

\begin_layout Plain Layout

			/* Disable Global Interrupt of GPIO */
\end_layout

\begin_layout Plain Layout

			gpio_custom_SetGlobalInterrupt(mygpio->gpio_custom, LOW);
\end_layout

\begin_layout Plain Layout

			/* Disable Interrupt on all port of GPIO*/
\end_layout

\begin_layout Plain Layout

			gpio_custom_SetInterruptMask(mygpio->gpio_custom, GPIO_PORT, LOW);	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			/* Memorize the value from GPIO port in <mygpio->r_or_w_value> */
\end_layout

\begin_layout Plain Layout

			mygpio->r_or_w_value = gpio_custom_GetValue(mygpio->gpio_custom, GPIO_PORT);
\end_layout

\begin_layout Plain Layout

			printf("The value in input to GPIO %s is: %08x
\backslash
n",mygpio->uiod,mygpio->r_or_w_value);			
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		/* In this case the driver don't read the register until the input that
 cause the interrupt is set to default low position */
\end_layout

\begin_layout Plain Layout

	//	while(*(unsigned*)gpio_custom_GetValue(mygpio->gpio_custom, GPIO_PORT)!=0);
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		/* test reenable interrupt */
\end_layout

\begin_layout Plain Layout

		ssize_t re_enable = 1;
\end_layout

\begin_layout Plain Layout

		/* to clean interrupt */
\end_layout

\begin_layout Plain Layout

		re_enable = write(mygpio->fd, &re_enable, sizeof(re_enable)); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		if (re_enable < sizeof(re_enable)) {
\end_layout

\begin_layout Plain Layout

			perror("write");
\end_layout

\begin_layout Plain Layout

			close(mygpio->fd);
\end_layout

\begin_layout Plain Layout

			exit(EXIT_FAILURE);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		/* Sent ack to GPIO peripheral */
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		gpio_custom_SetAckInterrupt(mygpio->gpio_custom,gpio_custom_GetStatusInterrupt
(mygpio->gpio_custom, GPIO_PORT), HIGH);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Writes <mygpio->r_or_w_value> in output to GPIO port.
\end_layout

\begin_layout Plain Layout

  * @param  [inout]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_write_gpio(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetEnable(mygpio->gpio_custom, GPIO_PORT, HIGH);
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetMode(mygpio->gpio_custom, GPIO_PORT, WRITE);
\end_layout

\begin_layout Plain Layout

	printf("Going to write onto GPIO %s the value %08x
\backslash
n", mygpio->uiod, mygpio->r_or_w_value);
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetValue(mygpio->gpio_custom, GPIO_PORT, LOW);  // Cleans previous
 values
\end_layout

\begin_layout Plain Layout

	gpio_custom_SetValue(mygpio->gpio_custom, mygpio->r_or_w_value, HIGH);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

  * @brief  Closes /dev/mem file.
\end_layout

\begin_layout Plain Layout

  * @param  [in]	mygpio: data stucture that contains GPIO data
\end_layout

\begin_layout Plain Layout

  * @retval None.
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

void mygpio_close_memory(mygpio_TypeDef* mygpio){
\end_layout

\begin_layout Plain Layout

	munmap((void*)(mygpio->gpio_custom->base_address),PAGE_SIZE);
\end_layout

\begin_layout Plain Layout

	close(mygpio->fd);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
